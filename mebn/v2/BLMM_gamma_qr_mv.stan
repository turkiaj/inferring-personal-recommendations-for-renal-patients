
data { 
  int<lower=0> N;   // number of observations
  int<lower=1> p;   // number of predictors
  int<lower=1> v;   // number of responses
  int<lower=1> J;   // number of groups in data (persons)
  int<lower=1> k;   // number of group-level predictors
  int<lower=1,upper=J> group[N]; //group indicator
  matrix[N,p] X;    // fixed-effect design matrix
  matrix[N,k] Z;    // random-effect design matrix
  vector[N] Y[v];    // responses
  real offset;
} 

transformed data { 
  
  matrix[N,p-1] X_t; // training input
  matrix[N,k] Z_t;   // training input
  vector[N] Y_t[v];   // training responses
  int t=1;           // index
  
  // QR reparameteratization of the model matrix
  // - there is a reparamization matrix for each response, 1..v

  matrix[N, p-1] Q_ast[v];
  matrix[p-1, p-1] R_ast[v];
  matrix[p-1, p-1] R_ast_inverse[v];

  for (n in 1:N)
  {
    // the intercept is removed from the model matrix 
    X_t[t,1:p-1] = X[n,2:p];
    Z_t[t] = Z[n];

    // loop all responses
    for (i in 1:v)
    {
      Y_t[i,t] = Y[i,n] + offset;
    }
      
    t += 1;
  }
    
  for (i in 1:v)
  {
    // thin and scale the QR decomposition
    Q_ast[i] = qr_thin_Q(X_t) * sqrt(N - 1);
    R_ast[i] = qr_thin_R(X_t) / sqrt(N - 1);
    R_ast_inverse[i] = inverse(R_ast[i]);  
  }
}

parameters { 
  // all parameters are vectorized based on response, 1..v
  real beta_Intercept[v];         // intercept 
  vector[p-1] theta_q[v];         // coefficients of Q_ast
  cholesky_factor_corr[k] L[v];   // Cholesky factor of group ranef corr matrix
  vector<lower=0>[k] sigma_b[v];  // group-level random-effect standard deviations
  vector[k] z[J,v];               // unscaled group-level effects
  real<lower=0> g_log_alpha[v];   // alpha (shape) parameter of the gamma distribution
}

transformed parameters {
  real<lower=0> g_alpha[v];       // alpha (shape) parameter of each v gamma distribution
  real<lower=0> sigma_e[v];       // residual standard deviations for each distribution v 
  vector[k] b[J,v];               // group-level effects (random effects), k x J x v - coef x patient x response

  // Premultiply diagonal matrix [sigma_b] with the Cholesky decomposition L of
  // the correlation matrix Sigma_b to get variance-covariance matrix of group-level effects

  // local scope for Lambda matrix
  {
    // diag(sigma_b) * L
    matrix[k, k] Lambda[v];      // Tau * Cholesky decomposition
    
    // loop all responses
    for (i in 1:v)
    {
      Lambda[i] = diag_pre_multiply(sigma_b[i], L[i]); 

      // Group-level effects are generated by multipying D (Sigma_b) with z 
      // that has standard normal distribution
      
      for(j in 1:J) 
        b[j,i] = Lambda[i] * z[j,i];    
    }
  }

  // loop all responses
  for (i in 1:v)
  {
    // - log transform alpha parameter to keep it positive
    g_alpha[i] = exp(g_log_alpha[i]);

    // estimate of variance 
    // (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4024993/)
    sigma_e[i] = log(1/g_alpha[i] + 1);
  }
}

model {
  
  // Priors for all responses
  for (i in 1:v)
  {
    beta_Intercept[i] ~ cauchy(0,10); // prior for the intercept following Gelman 2008

    // beta is reparameterized with QR
    // for(i in 2:p-1)
      //   beta[i] ~ cauchy(0,2.5); //prior for the slopes following Gelman 2008
   
    sigma_b[i] ~ student_t(3, 0, 10);
    
    // - standard normal prior for personal effects
    for (j in 1:J) {
      z[j,i] ~ normal(0,1);
    }
  
    // - LJK prior for personal effect Cholesky factor
    L[i] ~ lkj_corr_cholesky(1);
  }

  // brackets introduce a new scope for local variables that are not published in model
  {
    real mu[N];             // expected value 
    real g_beta[N];         // beta (rate) of Gamma distribution
    
    // TODO: tee vektorioperaatioina kun ei ole ARaa
    //matrix[N, p-1] Q_ast; * vector[p-1] theta_q;

    for (i in 1:v)
    {
      for (n in 1:N) 
      {
         //  X_t[n] * beta is reparameterized as Q_ast * theta_q
         mu[n] = beta_Intercept[i] + offset + Q_ast[i,n] * theta_q[i] + Z_t[n] * b[group[n],i];

         // identity link
         g_beta[n] = g_alpha[i] / mu[n];
      }
      
      //Y_t[i] ~ gamma(g_alpha[i], g_beta);
      
      target += gamma_lpdf(Y_t[i] | g_alpha[i], g_beta);
    }
  }

}

generated quantities {

  vector[p-1] beta[v];             // poulation-level effects (fixed effects)
  corr_matrix[k] C[v];            // correlation matrix 
  vector[N] Y_rep[v];             // repeated response
  vector[N] log_lik[v];           // log-likelihood for LOO
  real mu_hat;
  real g_beta_hat;
  vector[k-1] personal_effect[J,v];
  real personal_intercept[J,v];

  for (i in 1:v)
  {
    beta[i] = R_ast_inverse[i] * theta_q[i];     // coefficients on x

    // Correlation matrix of random-effects, C = L'L
    C[i] = multiply_lower_tri_self_transpose(L[i]);
  }

  // Posterior predictive distribution for model checking

  for (i in 1:v)
  {
    for (n in 1:N) 
    {
      mu_hat = beta_Intercept[i] + offset + X_t[n] * beta[i] + Z_t[n] * b[group[n],i];
  
      g_beta_hat = g_alpha[i] / mu_hat;
  
      Y_rep[i,n] = gamma_rng(g_alpha[i], g_beta_hat) - offset;
  
      // Compute log-Likelihood for LOO comparison of the models 
      log_lik[i,n] = gamma_lpdf(Y_t[i,n] | g_alpha[i], g_beta_hat);
    }
  
    // Finally, sample personal effects for each nutrient
    for (j in 1:J) 
    {
      // personal intercept
      personal_intercept[j,i] = beta_Intercept[i] + b[j,i][1];
  
      // beta vector does not include intercept, b is also sliced not to include it
      personal_effect[j,i] = beta[i] + b[j,i][2:k];
    }
  }

}


