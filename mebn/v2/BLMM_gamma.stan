
data { 
  int<lower=0> N;   // number of observations
  int<lower=1> p;   // number of predictors
  int<lower=1> J;   // number of groups in data (persons)
  int<lower=1> k;   // number of group-level predictors
  int<lower=1,upper=J> group[N]; //group indicator
  matrix[N,p] X;    // fixed-effect design matrix
  matrix[N,k] Z;    // random-effect design matrix
  vector[N] Y;      // response
  real offset;
} 

transformed data { 
  
  matrix[N,p-1] X_t; // training input
  matrix[N,k] Z_t;   // training input
  vector[N] Y_t;     // training response
  int t=1;           // index
  
  // QR reparameteratization of design matrix

  matrix[N, p-1] Q_ast;
  matrix[p-1, p-1] R_ast;
  matrix[p-1, p-1] R_ast_inverse;

  for (n in 1:N)
  {
    // the intercept is removed from the design matrix 
    X_t[t,1:p-1] = X[n,2:p];
    Z_t[t] = Z[n];
    Y_t[t] = Y[n] + offset;
    t += 1;
  }
  
  // thin and scale the QR decomposition
  Q_ast = qr_thin_Q(X_t) * sqrt(N - 1);
  R_ast = qr_thin_R(X_t) / sqrt(N - 1);
  R_ast_inverse = inverse(R_ast);  
}

parameters { 
  real beta_Intercept;            // intercept 
  vector[p-1] theta_q;            // coefficients on Q_ast
  cholesky_factor_corr[k] L;      // Cholesky factor of group ranef corr matrix
  vector<lower=0>[k] sigma_b;     // group-level random-effect standard deviations
  vector[k] z[J];                 // unscaled group-level effects
  real<lower=0> g_log_alpha;      // alpha (shape) parameter of the gamma distribution
}

transformed parameters {
  real<lower=0> g_alpha;          // alpha (shape) parameter of the gamma distribution
  real<lower=0> sigma_e;          // residual standard deviations 
  vector[k] b[J];                 // group-level effects (random effects)
  
  // Premultiply diagonal matrix [sigma_b] with the Cholesky decomposition L of
  // the correlation matrix Sigma_b to get variance-covariance matrix of group-level effects

  // local scope for Lambda matrix
  {
    // diag(sigma_b) * L
    matrix[k, k] Lambda;            // Tau * Cholesky decomposition
    Lambda = diag_pre_multiply(sigma_b, L); 
    
    // Group-level effects are generated by multipying D (Sigma_b) with z 
    // that has standard normal distribution
      
    for(j in 1:J) 
      b[j] = Lambda * z[j];    
  }

  // - log transform alpha parameter to keep it positive
  g_alpha = exp(g_log_alpha);
  
  // estimate of variance 
  // (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4024993/)
  sigma_e = log(1/g_alpha + 1);
}

model {
  
  // Priors
  beta_Intercept ~ cauchy(0,10); // prior for the intercept following Gelman 2008

  // for(i in 2:p-1)
  //   beta[i] ~ cauchy(0,2.5); //prior for the slopes following Gelman 2008
   
  sigma_b ~ student_t(3, 0, 10);
  L ~ lkj_corr_cholesky(1);
  
  // - standard normal prior for random effects
  for (j in 1:J)
    z[j] ~ normal(0,1);
    
  // brackets introduce a new scope for local variables that are not published in model
  {
    real mu[N];             // linear prediction 
    real g_beta[N];         // beta (rate) of Gamma distribution

    for (n in 1:N) 
    {
       //  X_t[n] * beta is reparameterized as Q_ast * theta_q
       mu[n] = beta_Intercept + offset + Q_ast[n] * theta_q + Z_t[n] * b[group[n]];

       // identity link
       g_beta[n] = g_alpha / mu[n];
    }
  
    Y_t ~ gamma(g_alpha, g_beta);
  }

}

generated quantities {

  vector[p-1] beta;               // poulation-level effects (fixed effects)
  corr_matrix[k] C;               // correlation matrix 
  vector[N] Y_rep;                // repeated response
  vector[N] log_lik;              // log-likelihood for LOO
  real mu_hat;
  real g_beta_hat;
  vector[k-1] personal_effect[J];
  real personal_intercept[J];

  beta = R_ast_inverse * theta_q; // coefficients on x

  // Correlation matrix of random-effects, C = L'L
  C = multiply_lower_tri_self_transpose(L); 
  
  // Posterior predictive distribution for model checking

  for (n in 1:N) 
  {
    mu_hat = beta_Intercept + offset + X_t[n] * beta + Z_t[n] * b[group[n]];
    
    //g_beta_hat = g_alpha / exp(mu_hat);
    g_beta_hat = g_alpha / mu_hat;
    
    Y_rep[n] = gamma_rng(g_alpha, g_beta_hat) - offset;
    
    // Compute log-Likelihood for later LOO comparison of the models 
    log_lik[n] = gamma_lpdf(Y[n] | g_alpha, g_beta_hat);
  }
  
  // Finally, sample personal effects for each nutrient
  for (j in 1:J) 
  {
    // personal intercept
    personal_intercept[j] = beta_Intercept + b[j][1];

    // beta vector does not include intercept, b is also sliced not to include it
    personal_effect[j] = beta + b[j][2:k];
  }

} 
