---
title: "Personal recommendation"
output: html_notebook
---

```{r setup, include=FALSE}
library(knitr)
library(kableExtra) # for HTML and Latex tables

knitr::opts_chunk$set(echo = TRUE, fig.align="center", fig.pos = 'H')

# this allows using tikz rendering for plots with "dev=tikz"
knit_hooks$set(plot = function(x, options) {
  if ('tikz' %in% options$dev && !options$external) {
    hook_plot_tex(x, options)
  } else hook_plot_md(x, options)
})

# Fix seed for random number generator for getting consistent results in kmeans etc.
fixed_seed <- 678

# Load common MEBN package
source("mebn/v3/MEBNv3.r")

```

```{r data_loading, echo=FALSE, message=FALSE, warning=FALSE}
library(lubridate)
library(dplyr)
library(tidyr)

# Read the data description
datadesc_fat_epros <- read.csv(file="data/DIALYSIS_data_description_fat_epros.csv", header = TRUE, sep = ";")

# Read the actual data matching the description
dialysis <- read.csv(file="data/DIALYSIS.csv", sep=";", dec=",")

# Define factors
dialysis$potilas <- factor(dialysis$potilas)
dialysis$nesterajoitus <- factor(dialysis$nesterajoitus)
dialysis$verenpainelaakitys <- factor(dialysis$verenpainelaakitys)
dialysis$verenrasvojen_laakitys <- factor(dialysis$verenrasvojenlaakitys)
dialysis$mielialalaakitys <- factor(dialysis$mielialalaakitys)
dialysis$fosforinsitoja <- factor(dialysis$fosforinsitoja)
dialysis$kaliuminsitoja <- factor(dialysis$kaliuminsitoja)
dialysis$anemian_hoito <- factor(dialysis$anemianhoito)
dialysis$diabeteslaakitys <- factor(dialysis$diabeteslaakitys)
dialysis$antibiootti <- factor(dialysis$antibiootti)
dialysis$marevan <- factor(dialysis$marevan)
dialysis$nesteenpoisto <- factor(dialysis$nesteenpoisto)
dialysis$ummetuslaake <- factor(dialysis$ummetuslaake)
dialysis$verenohennus <- factor(dialysis$verenohennus)
dialysis$akt_dvit <- factor(dialysis$aktdvit)
dialysis$renavit <- factor(dialysis$renavit)
dialysis$cad <- factor(dialysis$cad)

# Calculate missing E% for fats 
# https://fineli.fi/fineli/fi/ravintotekijat/2331

dialysis$mufaepros <- dialysis$mufa * 9 / dialysis$energiakcal * 100 # Rasvan energiakerroin on 37 kJ/g (9 kcal/g)
dialysis$pufaepros <- dialysis$pufa * 9 / dialysis$energiakcal * 100 # Rasvan energiakerroin on 37 kJ/g (9 kcal/g)
#dialysis$safaepros2 <- dialysis$safa * 9 / dialysis$energiakcal * 100 # Rasvan energiakerroin on 37 kJ/g (9 kcal/g)

# Add these new E% features as predictors
mufa_e <- datadesc_fat_epros[datadesc_fat_epros$Name=="safaepros",]
mufa_e$Name <- "mufaepros"
mufa_e$Unit <- "E%"
mufa_e$Description <- "Monounsaturated Fatty Acids, E%"
mufa_e$ShortDescription <- "MUFA, E%"
mufa_e$Descriptionfin <- "Mufa E%"
mufa_e$Lowerbound <- 0
mufa_e$Upperbound <- 18.1
datadesc_fat_epros <- rbind(datadesc_fat_epros, mufa_e)

pufa_e <- datadesc_fat_epros[datadesc_fat_epros$Name=="safaepros",]
pufa_e$Name <- "pufaepros"
pufa_e$Unit <- "E%"
pufa_e$Description <- "Polyunsaturated Fatty Acids, E%"
pufa_e$ShortDescription <- "PUFA, E%"
pufa_e$Descriptionfin <- "Pufa E%"
pufa_e$Lowerbound <- 0
pufa_e$Upperbound <- 8.8
datadesc_fat_epros <- rbind(datadesc_fat_epros, pufa_e)

# Remove g/d features from predictors
datadesc_fat_epros[datadesc_fat_epros$Name=="mufa",]$Order <- 0
datadesc_fat_epros[datadesc_fat_epros$Name=="pufa",]$Order <- 0

# gender: female = 1, male = 0
dialysis$sukupuoli <- factor(ifelse(dialysis$sukupuoli == "nainen", 1, 0))

# Days between laboratory test and food record interview
dialysis$responsedays <- difftime(as.Date(dialysis$labraaika, '%d.%m.%Y'), as.Date(dialysis$ravhaastaika, '%d.%m.%Y'), units = c("days"))

responsedays_desc <- datadesc_fat_epros[datadesc_fat_epros$Name=="ika",]
responsedays_desc$Order <- 0 # OMITTED !!
responsedays_desc$Distribution <- "Integer"  # Filter this out from normalization etc.
responsedays_desc$Name <- "responsedays"
responsedays_desc$Unit <- "days"
responsedays_desc$Description <- "responsetime"
responsedays_desc$Descriptionfin <- "vasteaika"
datadesc_fat_epros <- rbind(datadesc_fat_epros, responsedays_desc)

# important: dataset is ordered by successive patients and observations so that estimation works correctly
dialysis <- dialysis[order(dialysis$potilas, dialysis$havainto),]

# remove patients with one observation only

# dialysis
patients_with_two_obs <- dialysis %>% 
  group_by(potilas) %>% 
  summarise(havainto_sum = sum(havainto)) %>%
  filter(havainto_sum == 3) %>%
  select(potilas) %>%
  unlist() %>% as.vector()

dialysis <- dialysis[dialysis$potilas %in% patients_with_two_obs,]

# - reset patient levels
dialysis$potilas <- factor(dialysis$potilas)

# Define how to iterate through the graph
# - same targets
assumedpredictors <- datadesc_fat_epros[datadesc_fat_epros$Order==100,]
assumedtargets <- datadesc_fat_epros[datadesc_fat_epros$Order==200,]
```

```{r fig.width=10, fig.height=7}
source("mebn/v3/MEBNv3.r")

library(igraph)
library(ggraph)

initial_graph <- mebn.fully_connected_bipartite_graph(datadesc_fat_epros)

bipa_layout <- layout_as_bipartite(initial_graph, types = V(initial_graph)$type == "100", hgap = 1, vgap = 1)

# - flip layout sideways, from left to right
bipa_layout <- cbind(bipa_layout[,2], bipa_layout[,1])
V(initial_graph)[V(initial_graph)$type == "100"]$label.degree = pi # left side
V(initial_graph)[V(initial_graph)$type == "200"]$label.degree = 0 # right side

ggraph(initial_graph, layout = bipa_layout) +
  geom_edge_link(colour = "#AAAAAA") +
  geom_node_label(nudge_x = 0.05, aes(label = description, colour = "#000000")) +
  theme_bw() + 
  theme(axis.text.y = element_blank(), axis.text.x = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  labs(x = element_blank(), y = element_blank())

```

https://cran.r-project.org/web/packages/ggparty/vignettes/ggparty-graphic-partying.html

```{r}

```


```{r}

intake.df <- datadesc_fat_epros[datadesc_fat_epros$Order==100,]

ggplot(intake.df) + 
  theme_bw() +
  scale_x_continuous(breaks=c(0,2500,5800), limits = c(0,5850)) +
  geom_text(aes(x=2500,y=ShortDescription,label = ShortDescription), size=0.2)

```



```{r}

# TODO: jokaisesta muuttujasta tämän tyyppinen density ridge

pot_plot <- ggplot(intake_reasoning.df, aes(x = pot, y = reorder(person_text, max_recom_norm + as.numeric(accepted_recommandation_probability) * 100000), group = person_id)) +
      geom_density_ridges(aes(rel_min_height=0.01, scale = 1.0), fill = "#00BFC4", color = "#009FA4") +
      theme_bw() +
      scale_x_continuous(breaks=c(0,2500,5800), limits = c(0,5850)) +
      geom_text(stat = "unique", aes(x=2500, label=pot_text), size=2.5) +
      geom_vline(xintercept = 2500, linetype="solid", color = "black", size=0.2) +
      labs(x = element_blank(), y = "Patients") +
      theme(axis.text.x = element_text(size=6),axis.title = element_text(size=9), axis.text = element_text(size=7), plot.title = element_text(size=9)) +
      ggtitle("Pot. (mg/d)")


```

```{r graph_with_gamma_qr_mvcross_two_levels, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
dialysis_imputed <- readRDS("data/DIALYSIS_imputed_palb.rds")

no_holdout <- rep(0, nrow(dialysis_imputed))

initial_graph <- mebn.fully_connected_bipartite_graph(datadesc_fat_epros)

# add the dialysis treatment type as a grouping factor
dialysis_imputed$hoitoryhma <- as.factor(dialysis_imputed$hoitomuoto)

# and sort the data by treatment/patient/observation
dialysis_imputed <- dialysis_imputed[order(dialysis_imputed$hoitoryhma, 
                                           dialysis_imputed$potilas, dialysis_imputed$havainto),]

dialdiet_gamma_mv3_two_level <- mebn.bipartite_two_level_multivariate(
                                   reaction_graph = initial_graph, 
                                   inputdata = dialysis_imputed,
                                   targetdata = no_holdout,
                                   predictor_columns = assumedpredictors, 
                                   assumed_targets = assumedtargets, 
                                   group_column = "hoitoryhma",
                                   subject_column = "potilas",
                                   local_estimation = mebn.two_level_multivariate_sampling,
                                   local_model_cache = 
                                     "models/BLMM_gamma_mv_cross/two_levels", 
                                   stan_model_file = 
                                     "mebn/v2/BLMM_gamma_two_level_grouping.stan",
                                   normalize_values = TRUE)

write.graph(dialdiet_gamma_mv3_two_level, 
            "graphs/dialysis_gamma_two_level_grouping.graphml", "graphml")
```

```{r dialysis_gamma_mv_cross_2levels_ppc, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE, cache=TRUE, fig.cap="Posterior predictive check of the model where three concentrations and their parameters are stacked into one univariate model for estimating cross-model correlations."}

p <- mebn.multivariate_dens_overlays("models/BLMM_gamma_mv_cross/two_levels", assumedtargets, dialysis_imputed) 
#ggsave("figures/ppc_mv3_cross.pdf", plot = p, width = 4, height = 4)
p
```
```{r extract_personal_generative_models, eval=FALSE, echo=FALSE}
source("mebn/v3/MEBNv3.r")

# Extract generative models for patients with data from personal grouping

# - latent parameters from this model
latent_parameter_modeldir <- "models/BLMM_gamma_mv_cross/two_levels"
#latent_parameter_modeldir <- "models/BLMM_gamma_qr_multivariate3/imputed_palb/"
#latent_parameter_modeldir <- "models/BLMM_gamma_separate/"

# - use these predictors and targets
datadesc <- datadesc_fat_epros
target_variables <- assumedtargets

# - output personal generative models (graphml + rv samples) in this dir
graph_dir <- "graphs/mv3_cross_two_levels/"
#graph_dir <- "graphs/mv3_cross/"
#graph_dir <- "graphs/separate_pk_fppi/"

# Loop through patients and produce the models

dialysis <- readRDS("data/DIALYSIS_imputed_palb.rds")

# add the dialysis treatment type as a grouping factor
dialysis$hoitoryhma <- as.factor(dialysis$hoitomuoto)

patients <- levels(dialysis$potilas)

#for (person_id in 1:length(patients)) {

for (person_id in 36:36) {
  
  # - initial graph structure
  initial_graph <- mebn.fully_connected_bipartite_graph(datadesc)
  
  # - pick the estimated latent variables for all the persons
  local_distributions <- target_variables
  local_distributions$modelcache <- latent_parameter_modeldir
  
  # - get personal data, normalized and original
  
  # - statistics for the nutrition levels are calculated from normalized data (as it was in the likelihood estimation)
  predictors <- nrow(assumedpredictors)
  normalized_input <- sapply(1:predictors, mebn.scale_gaussians, data = dialysis, datadesc = assumedpredictors, log_transform_ln = FALSE)
  normalized_input_df <- as.data.frame(normalized_input)
  
  # - pick rows for the selected person
  subject_code <- levels(dialysis$potilas)[person_id]
  personal_data_df <- cbind(dialysis$potilas, normalized_input_df)
  personal_data_df <- personal_data_df[personal_data_df$`dialysis$potilas` == subject_code,]
  personal_data <- as.matrix(subset(personal_data_df, select = -c(`dialysis$potilas`)))
  
  # - store also these original stats in graph
  personal_data_org <- subset(dialysis[dialysis$potilas == subject_code,], select = as.vector(assumedpredictors$Name))
  personal_concentrations_org <- subset(dialysis[dialysis$potilas == subject_code,], select = as.vector(assumedtargets$Name))
  
  personal_model_dir <- paste0(graph_dir, person_id)
  
  # Generate a personal graph in directory
  
  group_id <- as.numeric(unique(dialysis[dialysis$potilas == subject_code,]$hoitoryhma))

  # one-level, univariate models
  #personal_graph <- mebn.extract_personal_graph(person_id, initial_graph, personal_model_dir, assumedpredictors, target_variables, latent_parameter_modeldir, personal_data, personal_data_org)

  # one-level model
  #personal_graph <- mebn.extract_personal_graph_from_mv(person_id, initial_graph, personal_model_dir, assumedpredictors, assumedtargets, latent_parameter_modeldir, personal_data, personal_data_org, personal_concentrations_org, datadesc)

  # two-level model
  personal_graph <- mebn.extract_multilevel_graph(person_id, group_id, initial_graph, personal_model_dir, assumedpredictors, assumedtargets, latent_parameter_modeldir, personal_data, personal_data_org, personal_concentrations_org, datadesc)
  
}

```

```{r simulated_MSE, eval=FALSE, echo=FALSE}
library(igraph)
source("mebn/v3/MEBNv3.r")

potassium_org_mean <- mean(dialysis$kalium) # 2755
potassium_org_sd <- sd(dialysis$kalium) # 949
  
phosphorous_org_mean <- mean(dialysis$fosfori) # 2755
phosphorous_org_sd <- sd(dialysis$fosfori) # 949

pk_mean <- mean(dialysis$pk)
fppi_mean <- mean(dialysis$fppi)
palb_mean <- mean(dialysis$palb, na.rm = TRUE)

mse_summary <- data.frame(matrix(ncol = 5, nrow = 0), row.names = NULL)

model_dir <- "mv3_cross_two_levels"
graph_dir <- paste0("graphs/",model_dir,"/")

for (person_id in 36:36) {

  print(paste0("Simulating patient ", person_id))

  subject_code <- levels(dialysis$potilas)[person_id]
  treatment <- unique(dialysis[dialysis$potilas == subject_code,]$hoitomuoto)
  
  # Normal ranges of concentration are personalized
  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_target_guidelines(personal_info, patient_in_dialysis = TRUE)
  
  recommeded_concentrations$lower_limits <- recommeded_concentrations$lower_limits
  recommeded_concentrations$upper_limits <- recommeded_concentrations$upper_limits
  
  personal_model_dir <- paste0(graph_dir,person_id)
  personal_graph <- read.graph(paste0(personal_model_dir, "/personal_graph.graphml"), "graphml")
  
  # Sample diet proposals and matching concentration predictions
  
  # Omit P-Alb
  #V(personal_graph)["palb"]$type <- 300
  
  repeat_model <- mebn.Query(reaction_graph = personal_graph,
                         graph_dir = personal_model_dir,
                         queried_nodes = c("kalium","fosfori"),
                         query = recommeded_concentrations,
                         proposal_limits = c(((0 - potassium_org_mean) / potassium_org_sd),
                                           ((5800 - potassium_org_mean) / potassium_org_sd),
                                           ((0 - phosphorous_org_mean) / phosphorous_org_sd),
                                           ((2550 - phosphorous_org_mean) / phosphorous_org_sd)),                         
                         stan_model_file = "diet/general_intake_recommendation.stan",
                         conc_lower_limits = as.vector(recommeded_concentrations$lower_limits),
                         conc_upper_limits = as.vector(recommeded_concentrations$upper_limits),
                         beta_point_est = "mean",
                         param_point_est = "mean",
                         X_point_est = "mean",
                         posterior_samples = 1,
                         X_sd_coef = 1,
                         repeat_only = 1)

  repeats <- rstan::extract(repeat_model)
 
  pk <- repeats$concentration[,,1]
  fppi <- repeats$concentration[,,2]
  palb <- repeats$concentration[,,3]
   
  true_concs <- dialysis %>%
       filter(potilas == subject_code) %>%
       select(havainto, pk, fppi, palb)
  
  personal_mse <- cbind(subject_code,
                            model_dir,
                            mebn.NRMSE(mean(pk), mean(true_concs$pk), pk_mean),
                            mebn.NRMSE(mean(fppi), mean(true_concs$fppi), fppi_mean),
                            mebn.NRMSE(mean(palb), mean(true_concs$palb), palb_mean))

  mse_summary <- rbind(mse_summary, personal_mse)
}

colnames(mse_summary) <- c("subject", "reaction_model", "pk_nrmse", "fppi_nrmse", "palb_nrmse")

saveRDS(mse_summary, "model_evaluation/NRMSE_comparison_mv_models.rds")
write.csv2(mse_summary, file="model_evaluation/NRMSE_comparison_mv_models.csv", row.names = FALSE)

mse_summary

```

```{r recommendation_with_custom_utility, eval=FALSE,echo=FALSE, message=FALSE}
source("mebn/v3/MEBNv3.r")
library(igraph)
library(gridExtra)
library(dplyr)
  
# Query parameters
simulation <- "X50_B50_A50_I50"

# - data parameters
graph_dir <- "graphs/mv3_cross_two_levels/"

datadesc <- datadesc_fat_epros

# The conditioned variables are introduced in data description
datadesc$Conditioned <- 0 
datadesc[datadesc$Name == "kalium",]$Conditioned <- 1
datadesc[datadesc$Name == "fosfori",]$Conditioned <- 1
#datadesc[datadesc$Name == "protepros",]$Conditioned <- 1

# Calculate statistics for normalizing the data

org_stats <- data.frame(name = subset(assumedpredictors$Name, assumedpredictors$Distribution == "Gaussian"))
org_stats$mean <- sapply(org_stats$name, function(x) mean(dialysis[[x]]))
org_stats$sd <- sapply(org_stats$name, function(x) sd(dialysis[[x]]))

uniform_proposaldist_limits <- c(((as.numeric(datadesc[datadesc$Name=="kalium",]$Lowerbound) - org_stats[org_stats$name == "kalium",]$mean) / org_stats[org_stats$name == "kalium",]$sd),
                                 ((as.numeric(datadesc[datadesc$Name=="kalium",]$Upperbound) - org_stats[org_stats$name == "kalium",]$mean) / org_stats[org_stats$name == "kalium",]$sd),
                                 ((as.numeric(datadesc[datadesc$Name=="fosfori",]$Lowerbound) - org_stats[org_stats$name == "fosfori",]$mean) / org_stats[org_stats$name == "fosfori",]$sd),
                                 ((as.numeric(datadesc[datadesc$Name=="fosfori",]$Upperbound) - org_stats[org_stats$name == "fosfori",]$mean) / org_stats[org_stats$name == "fosfori",]$sd),
                                 ((as.numeric(datadesc[datadesc$Name=="protepros",]$Lowerbound) - org_stats[org_stats$name == "protepros",]$mean) / org_stats[org_stats$name == "protepros",]$sd),
                                 ((as.numeric(datadesc[datadesc$Name=="protepros",]$Upperbound) - org_stats[org_stats$name == "protepros",]$mean) / org_stats[org_stats$name == "protepros",]$sd))

# - collect personal statistics in this data frame
patient_summary <- data.frame(matrix(ncol = 19, nrow = 0), row.names = NULL)

colnames(patient_summary) <- c("person_id", "subject_code", "treatment", "accepted", "max_conc_prob", "max_pk_prob", "max_fppi_prob", "max_palb_prob", "potassium_low", "phosphorous_low", "potassium_high", "phosphorous_high","pk_min","pk_max", "fppi_min", "fppi_max", "palb_min", "palb_max")

#for (person_id in 1:37) {
  
  person_id <- 36

  print(paste0("Simulating patient ", person_id))

  subject_code <- levels(dialysis$potilas)[person_id]
  treatment <- unique(dialysis[dialysis$potilas == subject_code,]$hoitomuoto)
  
  # Normal ranges of concentration are personalized
  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_target_guidelines(personal_info, patient_in_dialysis = TRUE)
  
  #print(paste0("personal lower limits: ", as.vector(recommeded_concentrations$lower_limits)))
  #print(paste0("personal upper limits: ", as.vector(recommeded_concentrations$upper_limits)))
  
  personal_model_dir <- paste0(graph_dir,person_id)
  personal_graph <- read.graph(paste0(personal_model_dir, "/personal_graph.graphml"), "graphml")
  
  # Sample diet proposals and matching concentration predictions
  
  intake_model <- mebn.Query(reaction_graph = personal_graph,
                           graph_dir = personal_model_dir,
                           queried_nodes = c("kalium","fosfori","protepros"),
                           query = recommeded_concentrations,
                           proposal_limits = uniform_proposaldist_limits,
                           stan_model_file = "diet/general_intake_recommendation.stan",
                           conc_lower_limits = as.vector(recommeded_concentrations$lower_limits),
                           conc_upper_limits = as.vector(recommeded_concentrations$upper_limits),
                           beta_point_est = "mean",
                           param_point_est = "mean",
                           X_sd_coef = 0, # coef = 0 forces to use the point estimate
                           X_point_est = "mean",
                           posterior_samples = 1000,
                           repeat_only = 0,
                           condition_in_repeat = 0)
  
  # Extract all the samples and correlate concentrations and intake with proposal ids
  
  result <- rstan::extract(intake_model)

  pk <- result$concentration[,,1]
  fppi <- result$concentration[,,2]
  palb <- result$concentration[,,3]

  proposals <- 1:dim(pk)[1]
  proposal_samples <- 1:dim(pk)[2]

  concs.df <- data.frame(proposal=rep(proposals, each = length(proposal_samples)), pk=as.vector(t(pk)),fppi=as.vector(t(fppi)),palb=as.vector(t(palb)))
  
  # Get the original scale levels of potassium and potassium from each diet proposal
  pot <- result$Q[,1] * org_stats[org_stats$name == "kalium",]$sd + org_stats[org_stats$name == "kalium",]$mean
  pho <- result$Q[,2] * org_stats[org_stats$name == "fosfori",]$sd + org_stats[org_stats$name == "fosfori",]$mean
  prot <- result$Q[,3] * org_stats[org_stats$name == "protepros",]$sd + org_stats[org_stats$name == "protepros",]$mean
  
  intake_proposals.df <- data.frame(proposal=proposals, pot=as.vector(pot),pho=as.vector(pho),prot=as.vector(prot))
  
  #  Calculate probability of each proposal being within the recommended concentration limits.
  #  The calculation is done based on empirical cumulative distribution function (ecdf) for each concentration distribution. 
  
  pk_recommendations <- c(recommeded_concentrations$lower_limits[1], recommeded_concentrations$upper_limits[1])
  fppi_recommendations <- c(recommeded_concentrations$lower_limits[2], recommeded_concentrations$upper_limits[2])
  palb_recommendations <- c(recommeded_concentrations$lower_limits[3], recommeded_concentrations$upper_limits[3])

  proposal_probs.df <- concs.df %>%
  select(proposal,pk,fppi,palb) %>%
  group_by(proposal) %>%
  summarise(
    pk_prob = (ecdf(pk)(pk_recommendations[2]) - ecdf(pk)(pk_recommendations[1])),
    fppi_prob = (ecdf(fppi)(fppi_recommendations[2]) - ecdf(fppi)(fppi_recommendations[1])),
    palb_prob = (ecdf(palb)(palb_recommendations[2]) - ecdf(palb)(palb_recommendations[1])),
    lowest_conc_prob = min(pk_prob, fppi_prob, palb_prob),
    iid_prob = pk_prob * fppi_prob * palb_prob,
  )
  
  # Filter all accepted diet proposals with a fixed probability limit. 
  acceptance_probability <- 0.50
  
  #   This is denoted with constant 'c' in Algorithm 1.
  recommandation_probability_levels <- c(0.90, 0.80)
  
  accepted <- 0

  conc_limits <- concs.df %>%
  select(pk,fppi,palb) %>%
  summarise(
            pk_low = min(pk), 
            fppi_low = min(fppi), 
            palb_low = min(palb),
            pk_high = max(pk), 
            fppi_high = max(fppi), 
            palb_high = max(palb)
  )

  # This requires all concentrations from one proposal to be accepted
  # distribution of accepted proposals    

  accepted_proposals.df <- proposal_probs.df %>%
    filter(lowest_conc_prob >= acceptance_probability) %>%
    as.data.frame()

  print(paste0("Proposals accepted ", nrow(accepted_proposals.df)))
  
  # Join intake and resulting concentrations
  accepted_intake.df <- accepted_proposals.df %>% inner_join(intake_proposals.df, by="proposal")

  # Highest probability that can be reached  
  max_conc_prob <- max(proposal_probs.df$lowest_conc_prob)

  # Search for the widest nutrient intake range within the accepted proposals  

  accepted <- 0
  min_pot <- -1
  min_pho <- -1 
  max_pot <- -1
  max_pho <- -1

  accepted_recommandation_probability <- 0

  # - Do we have any accepted proposals?
  if (nrow(accepted_intake.df) > 0)
  {
    saveRDS(accepted_intake.df, paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/accepted_intake_",person_id,".rds"))

    # Loop possible recommandation_probability_levels and fallback to lower level if higher returns empty
    
    for (recommandation_probability in recommandation_probability_levels)
    {
      # Filter recommendation distributions
      recommendation_intake.df <- accepted_intake.df %>%
        filter(lowest_conc_prob >= recommandation_probability) %>%
        as.data.frame()
      
      print(paste0("Proposals narrowed to ", nrow(recommendation_intake.df)))
  
     if (nrow(recommendation_intake.df) > 0)
     {
        accepted <- 1
        accepted_recommandation_probability <- recommandation_probability
  
        # Pick 2.5% and 97.5% quantiles of recommendation posteriors as recommendation limits   
        pot_quantiles <- quantile(recommendation_intake.df$pot, probs = c(0.025,0.975))
        pho_quantiles <- quantile(recommendation_intake.df$pho, probs = c(0.025,0.975))
    
        # And then closest sampled proposals matching those limits
        min_pot_row <- recommendation_intake.df[which.min(abs(recommendation_intake.df$pot-pot_quantiles[1])),]
        max_pot_row <- recommendation_intake.df[which.min(abs(recommendation_intake.df$pot-pot_quantiles[2])),]
        min_pho_row <- recommendation_intake.df[which.min(abs(recommendation_intake.df$pho-pho_quantiles[1])),]
        max_pho_row <- recommendation_intake.df[which.min(abs(recommendation_intake.df$pho-pho_quantiles[2])),]
    
        # - and nutrient levels
        min_pot <- as.numeric(min_pot_row$pot)
        max_pot <- as.numeric(max_pot_row$pot)
        min_pho <- as.numeric(min_pho_row$pho)
        max_pho <- as.numeric(max_pho_row$pho)
        
        # - concentrations matching those proposals    
        concs_minmax.df <- concs.df[concs.df$proposal %in% c(min_pot_row$proposal,max_pot_row$proposal,min_pho_row$proposal,max_pho_row$proposal),]
        
        saveRDS(concs_minmax.df, paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/concs_minmax_",person_id,".rds"))
        
        # Break out from loop with this probability
        break
     } 
      else
     {
        accepted <- 0
        min_pot <- -1
        min_pho <- -1 
        max_pot <- -1
        max_pho <- -1
     }
    }
  #}

  # Here the min and max concentrations match the nutrient recommendations
  personal_intake <- cbind(person_id,
                                   subject_code,
                                   treatment,
                                   accepted,
                                   max_conc_prob,
                                   max_pk_prob = max(proposal_probs.df$pk_prob),
                                   max_fppi_prob = max(proposal_probs.df$fppi_prob),
                                   max_palb_prob = max(proposal_probs.df$palb_prob),
                                   min_pot, 
                                   min_pho, 
                                   max_pot, 
                                   max_pho,
                                   accepted_recommandation_probability)

  personal_recommendation <- cbind(personal_intake, conc_limits)
  patient_summary <- rbind(patient_summary,personal_recommendation)

  saveRDS(personal_recommendation, paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/overviews/personal_recommendation_",person_id,".rds"))
} 

saveRDS(patient_summary, paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/recommendation_summary_posterior_params.rds"))

```

```{r}

# pot -2.897167 - 3.137178
# pho -2.74657 - 3.97615

pot_prior_dens <- result$pot_prior * potassium_org_sd + potassium_org_mean
pot_prior_dens <- as.data.frame(result$pot_prior)

pot_prior_dens

pot_prior <- ggplot(pot_prior_dens) + 
    geom_density(aes(x = pot), fill = "#0000FF", colour = "#0000FF", alpha = 0.2, show.legend = TRUE) +
    labs(x = "Potassium (mg/d)", y = "") +
    scale_x_continuous(limits=c(0,5800), breaks=c(0,1000,2000,3000,4000,5000,5800)) +
    theme_bw() +
    theme(axis.text.y = element_blank())

pot_post <- ggplot(subset(accepted_intake.df, lowest_conc_prob >= 0.50)) + 
    geom_density(aes(x = pot), fill = "#0000FF", colour = "#0000FF", alpha = 0.2, show.legend = TRUE) +
    labs(x = "Potassium (mg/d)", y = "") +
    scale_x_continuous(limits=c(0,5800), breaks=c(0,1000,2000,3000,4000,5000,5800)) +
    theme_bw() +
    theme(axis.text.y = element_blank())

pot_prior
pot_post
```

```{r recommendation_overview_simulation, eval=FALSE,echo=FALSE, message=FALSE}
source("mebn/v3/MEBNv3.r")
library(igraph)
library(gridExtra)
library(dplyr)
  
# Query parameters
simulation <- "X50_B50_A50_I50"

# - data parameters
graph_dir <- "graphs/mv3_cross_two_levels/"

# - evidence / query parameters
#pk_recommendations <- c(3.4,4.7)
#fppi_recommendations <- c(0.4,1.8)
#palb_recommendations <- c(34,48)
#recommeded_concentrations <- t(array(c(pk_recommendations, fppi_recommendations, palb_recommendations), dim = c(2,3)))

# TODO:
# Condition also the protein intake

datadesc <- datadesc_fat_epros

# The conditioned variables are introduced in data description
datadesc$Conditioned <- 0 
datadesc[datadesc$Name == "kalium",]$Conditioned <- 1
datadesc[datadesc$Name == "fosfori",]$Conditioned <- 1
#datadesc[datadesc$Name == "protepros",]$Conditioned <- 1

potassium_org_mean <- mean(dialysis$kalium) # 2755
potassium_org_sd <- sd(dialysis$kalium) # 949
  
phosphorous_org_mean <- mean(dialysis$fosfori) # 2755
phosphorous_org_sd <- sd(dialysis$fosfori) # 949

uniform_proposaldist_limits <- c(((datadesc[datadesc$Name=="kalium",]$Lowerbound - potassium_org_mean) / potassium_org_sd),
                                ((datadesc[datadesc$Name=="kalium",]$Upperbound - potassium_org_mean) / potassium_org_sd),
                                ((datadesc[datadesc$Name=="fosfori",]$Lowerbound - phosphorous_org_mean) / phosphorous_org_sd),
                                ((datadesc[datadesc$Name=="fosfori",]$Upperbound - phosphorous_org_mean) / phosphorous_org_sd))

# - collect personal statistics in this data frame
patient_summary <- data.frame(matrix(ncol = 19, nrow = 0), row.names = NULL)

colnames(patient_summary) <- c("person_id", "subject_code", "treatment", "accepted", "max_conc_prob", "max_pk_prob", "max_fppi_prob", "max_palb_prob", "potassium_low", "phosphorous_low", "potassium_high", "phosphorous_high","pk_min","pk_max", "fppi_min", "fppi_max", "palb_min", "palb_max")

#for (person_id in 1:37) {
  
  person_id <- 36

  print(paste0("Simulating patient ", person_id))

  subject_code <- levels(dialysis$potilas)[person_id]
  treatment <- unique(dialysis[dialysis$potilas == subject_code,]$hoitomuoto)
  
  # Normal ranges of concentration are personalized
  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_target_guidelines(personal_info, patient_in_dialysis = TRUE)
  
  print(paste0("personal lower limits: ", as.vector(recommeded_concentrations$lower_limits)))
  print(paste0("personal upper limits: ", as.vector(recommeded_concentrations$upper_limits)))
  
  personal_model_dir <- paste0(graph_dir,person_id)
  personal_graph <- read.graph(paste0(personal_model_dir, "/personal_graph.graphml"), "graphml")
  
  # Sample diet proposals and matching concentration predictions
  
  intake_model <- mebn.Query(reaction_graph = personal_graph,
                           graph_dir = personal_model_dir,
                           queried_nodes = c("kalium","fosfori"),
                           query = recommeded_concentrations,
                           proposal_limits = c(((0 - potassium_org_mean) / potassium_org_sd),
                                             ((5800 - potassium_org_mean) / potassium_org_sd),
                                             ((0 - phosphorous_org_mean) / phosphorous_org_sd),
                                             ((2550 - phosphorous_org_mean) / phosphorous_org_sd)),
                           stan_model_file = "diet/general_intake_recommendation.stan",
                           conc_lower_limits = as.vector(recommeded_concentrations$lower_limits),
                           conc_upper_limits = as.vector(recommeded_concentrations$upper_limits),
                           beta_point_est = "mean",
                           param_point_est = "mean",
                           X_sd_coef = 0, # coef = 0 forces to use the point estimate
                           X_point_est = "mean",
                           posterior_samples = 1000,
                           repeat_only = 0,
                           condition_in_repeat = 0)
  
  # Extract all the samples and correlate concentrations and intake with proposal ids
  
  result <- rstan::extract(intake_model)

  pk <- result$concentration[,,1]
  fppi <- result$concentration[,,2]
  palb <- result$concentration[,,3]

  proposals <- 1:dim(pk)[1]
  proposal_samples <- 1:dim(pk)[2]

  concs.df <- data.frame(proposal=rep(proposals, each = length(proposal_samples)), pk=as.vector(t(pk)),fppi=as.vector(t(fppi)),palb=as.vector(t(palb)))
  
  # Get the original scale levels of potassium and potassium from each diet proposal
  pot <- result$Q_pred[,1] * potassium_org_sd + potassium_org_mean
  pho <- result$Q_pred[,2] * phosphorous_org_sd + phosphorous_org_mean
  
  intake_proposals.df <- data.frame(proposal=proposals, pot=as.vector(pot),pho=as.vector(pho))
  
  #  Calculate probability of each proposal being within the recommended concentration limits.
  #  The calculation is done based on empirical cumulative distribution function (ecdf) for each concentration distribution. 
  
  pk_recommendations <- c(recommeded_concentrations$lower_limits[1], recommeded_concentrations$upper_limits[1])
  fppi_recommendations <- c(recommeded_concentrations$lower_limits[2], recommeded_concentrations$upper_limits[2])
  palb_recommendations <- c(recommeded_concentrations$lower_limits[3], recommeded_concentrations$upper_limits[3])

  proposal_probs.df <- concs.df %>%
  select(proposal,pk,fppi,palb) %>%
  group_by(proposal) %>%
  summarise(
    pk_prob = (ecdf(pk)(pk_recommendations[2]) - ecdf(pk)(pk_recommendations[1])),
    fppi_prob = (ecdf(fppi)(fppi_recommendations[2]) - ecdf(fppi)(fppi_recommendations[1])),
    palb_prob = (ecdf(palb)(palb_recommendations[2]) - ecdf(palb)(palb_recommendations[1])),
    lowest_conc_prob = min(pk_prob, fppi_prob, palb_prob),
    iid_prob = pk_prob * fppi_prob * palb_prob,
  )
  
  # Filter all accepted diet proposals with a fixed probability limit. 
  acceptance_probability <- 0.50
  
  #   This is denoted with constant 'c' in Algorithm 1.
  #recommandation_probability <- 0.90

  recommandation_probability_levels <- c(0.90, 0.80)
  
  accepted <- 0

  conc_limits <- concs.df %>%
  select(pk,fppi,palb) %>%
  summarise(
            pk_low = min(pk), 
            fppi_low = min(fppi), 
            palb_low = min(palb),
            pk_high = max(pk), 
            fppi_high = max(fppi), 
            palb_high = max(palb)
  )

  # This requires all concentrations from one proposal to be accepted
  # distribution of accepted proposals    

  accepted_proposals.df <- proposal_probs.df %>%
    filter(lowest_conc_prob >= acceptance_probability) %>%
    as.data.frame()

  print(paste0("Proposals accepted ", nrow(accepted_proposals.df)))
  
  # Join intake and resulting concentrations
  accepted_intake.df <- accepted_proposals.df %>% inner_join(intake_proposals.df, by="proposal")

  # Highest probability that can be reached  
  max_conc_prob <- max(proposal_probs.df$lowest_conc_prob)

  # Search for the widest nutrient intake range within the accepted proposals  

  accepted <- 0
  min_pot <- -1
  min_pho <- -1 
  max_pot <- -1
  max_pho <- -1

  accepted_recommandation_probability <- 0

  # - Do we have any accepted proposals?
  if (nrow(accepted_intake.df) > 0)
  {
    saveRDS(accepted_intake.df, paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/accepted_intake_",person_id,".rds"))

    # Loop possible recommandation_probability_levels and fallback to lower level if higher returns empty
    
    for (recommandation_probability in recommandation_probability_levels)
    {
      # Filter recommendation distributions
      recommendation_intake.df <- accepted_intake.df %>%
        filter(lowest_conc_prob >= recommandation_probability) %>%
        as.data.frame()
      
      print(paste0("Proposals narrowed to ", nrow(recommendation_intake.df)))
  
     if (nrow(recommendation_intake.df) > 0)
     {
        accepted <- 1
        accepted_recommandation_probability <- recommandation_probability
  
        # Pick 2.5% and 97.5% quantiles of recommendation posteriors as recommendation limits   
        pot_quantiles <- quantile(recommendation_intake.df$pot, probs = c(0.025,0.975))
        pho_quantiles <- quantile(recommendation_intake.df$pho, probs = c(0.025,0.975))
    
        # And then closest sampled proposals matching those limits
        min_pot_row <- recommendation_intake.df[which.min(abs(recommendation_intake.df$pot-pot_quantiles[1])),]
        max_pot_row <- recommendation_intake.df[which.min(abs(recommendation_intake.df$pot-pot_quantiles[2])),]
        min_pho_row <- recommendation_intake.df[which.min(abs(recommendation_intake.df$pho-pho_quantiles[1])),]
        max_pho_row <- recommendation_intake.df[which.min(abs(recommendation_intake.df$pho-pho_quantiles[2])),]
    
        # - and nutrient levels
        min_pot <- as.numeric(min_pot_row$pot)
        max_pot <- as.numeric(max_pot_row$pot)
        min_pho <- as.numeric(min_pho_row$pho)
        max_pho <- as.numeric(max_pho_row$pho)
        
        # - concentrations matching those proposals    
        concs_minmax.df <- concs.df[concs.df$proposal %in% c(min_pot_row$proposal,max_pot_row$proposal,min_pho_row$proposal,max_pho_row$proposal),]
        
        saveRDS(concs_minmax.df, paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/concs_minmax_",person_id,".rds"))
        
        # Break out from loop with this probability
        break
     } 
      else
     {
        accepted <- 0
        min_pot <- -1
        min_pho <- -1 
        max_pot <- -1
        max_pho <- -1
     }
    }
  #}

  # Here the min and max concentrations match the nutrient recommendations
  personal_intake <- cbind(person_id,
                                   subject_code,
                                   treatment,
                                   accepted,
                                   max_conc_prob,
                                   max_pk_prob = max(proposal_probs.df$pk_prob),
                                   max_fppi_prob = max(proposal_probs.df$fppi_prob),
                                   max_palb_prob = max(proposal_probs.df$palb_prob),
                                   min_pot, 
                                   min_pho, 
                                   max_pot, 
                                   max_pho,
                                   accepted_recommandation_probability)

  personal_recommendation <- cbind(personal_intake, conc_limits)
  patient_summary <- rbind(patient_summary,personal_recommendation)

  saveRDS(personal_recommendation, paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/overviews/personal_recommendation_",person_id,".rds"))
} 

saveRDS(patient_summary, paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/recommendation_summary_posterior_params.rds"))

```

```{r party, cache=FALSE, eval=TRUE, echo=FALSE,message=FALSE, warning=FALSE, fig.cap="Figure shows detailed intake recommendation for patient 10 from the previous recommendation table. The intake plot on the left shows the posterior samples of diet configurations that result concentrations of plasma potassium (P-K), fasting plasma phosphate (fP-Pi) and plasma albumin (P-Alb) to stay within their recommended limits. These levels are marked with vertical solid lines in the concentration panels. The black point in the middle of intake plot represents the patient's current potassium and phosphorous intake. Current concentrations matching this intake are shown with dashed vertical lines. Reported recommendation is shown with a rectangle that contains $95\\%$ of diet proposals that result recommended concentrations over $90\\%$ accuracy. Colouring of the rectangle sides match the concentration estimates in the right hand panels. The figure is plotted with ggplot2 package for R language (v 3.3.5, https://ggplot2.tidyverse.org)."}
library(ggplot2)
library(gridExtra)
library(ggrepel)
library(dplyr)

# Plot the personal recommendations
for (person_id in 36:36) {
  
  subject_code <- levels(dialysis$potilas)[person_id]

  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_target_guidelines(personal_info, patient_in_dialysis = TRUE)

  pk_recommendations <- c(recommeded_concentrations$lower_limits[1], recommeded_concentrations$upper_limits[1])
  fppi_recommendations <- c(recommeded_concentrations$lower_limits[2], recommeded_concentrations$upper_limits[2])
  palb_recommendations <- c(recommeded_concentrations$lower_limits[3], recommeded_concentrations$upper_limits[3])
    
  simulation <- "X50_B50_A50_I50"
  
  accepted_intake <- paste0("./patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/accepted_intake_",person_id,".rds")
  
  if (file.exists(accepted_intake)) {
    personal_recommendation <- paste0("./patient_summary/mv3_cross_two_levels/simulation",simulation,"/overviews/personal_recommendation_",person_id,".rds")
    patient_summary <- readRDS(personal_recommendation)
    
    info <- patient_summary[patient_summary$person_id==person_id,]
    min_k <- min(dialysis[dialysis$potilas == info$subject_code,]$kalium)
    max_k <- max(dialysis[dialysis$potilas == info$subject_code,]$kalium)
    avg_k <- mean(dialysis[dialysis$potilas == info$subject_code,]$kalium)
    
    min_f <- min(dialysis[dialysis$potilas == info$subject_code,]$fosfori)
    max_f <- max(dialysis[dialysis$potilas == info$subject_code,]$fosfori)
    avg_f <- mean(dialysis[dialysis$potilas == info$subject_code,]$fosfori)
    
    # these are not anymore retrieved at simulation
    
    true_concs <- dialysis %>%
     filter(potilas == subject_code) %>%
     select(havainto, pk, fppi, palb)

    info$true_pk <- mean(true_concs$pk)
    info$true_fppi <- mean(true_concs$fppi)
    info$true_palb <- mean(true_concs$palb)
    
    accepted_intake.df <- readRDS(accepted_intake)
  
    if (patient_summary$min_pot != -1)
    {
      concs_minmax.df <- readRDS(paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/concs_minmax_",person_id,".rds"))
    }
    
    rec_file <- paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/overviews/personal_recommendation_",person_id,".rds")
    personal_recommendation.df <- readRDS(rec_file)

    MyPalette <- c("#2860F6", "#FF7F0E", "#00BFC4", "#D62728", "#AAAAAA")

    accepted_intake.df$limiting_proposal <- sapply(accepted_intake.df$proposal, function(x) ifelse(x %in% concs_minmax.df$proposal,x,1000000))
    
    lim_proposals <- accepted_intake.df %>% filter(limiting_proposal < 1000000)

    min_pot <- lim_proposals[which.min(lim_proposals$pot),]$proposal
    max_pot <- lim_proposals[which.max(lim_proposals$pot),]$proposal
    min_pho <- lim_proposals[which.min(lim_proposals$pho),]$proposal
    max_pho <- lim_proposals[which.max(lim_proposals$pho),]$proposal

    # Order density colors like this
    
    proposal_order <- data.frame(proposal = c(min_pot, max_pot, min_pho, max_pho))
    proposal_order$color_order <- c(1,2,3,4)
    
    concs_minmax.df <- concs_minmax.df %>% inner_join(proposal_order, by = "proposal")
    
    # Plotting

    pot_plot <- ggplot(subset(accepted_intake.df, lowest_conc_prob >= 0.50)) + 
        geom_density(aes(x = pot), fill = "#0000FF", colour = "#0000FF", alpha = 0.2, show.legend = TRUE) +
        labs(x = "Potassium (mg/d)", y = "") +
        scale_x_continuous(limits=c(0,5800), breaks=c(0,1000,2000,3000,4000,5000,5800)) +
        theme_bw() +
        theme(axis.text.y = element_blank())

    pho_plot <- ggplot(subset(accepted_intake.df, lowest_conc_prob >= 0.50)) + 
        geom_density(aes(x = pho), fill = "#0000FF", colour = "#0000FF", alpha = 0.2, show.legend = TRUE) +
        labs(x = "Phosphorous (mg/d)", y = "") +
        scale_x_continuous(limits=c(0,2550), breaks=c(0,500,1000,1500,2000,2550)) +  
        theme_bw() +
        theme(axis.text.y = element_blank())
        
    # what kind of concentration these intakes result?
    pk_plot <- ggplot(concs_minmax.df, aes(x = pk, group=factor(color_order))) +
      geom_density(aes(colour=factor(color_order)), show.legend = FALSE) +
      labs(x = "P-K (mmol/l)", y = NULL, title=element_blank()) +
      geom_vline(xintercept = pk_recommendations, linetype="solid", color = "black", size=0.2) +
      geom_vline(xintercept = as.numeric(info$true_pk), linetype="dashed", color = "black", size=0.5) +
      scale_x_continuous(breaks=c(pk_recommendations,3,4,5,6), limits=c(pk_recommendations,2,3,4,5,6,7)) +
      scale_colour_manual(values = MyPalette) +
      annotate("rect", xmin=-Inf, xmax=pk_recommendations[1], ymax=Inf, ymin=-Inf, alpha = .2) + 
      annotate("rect", xmin=pk_recommendations[2], xmax=Inf, ymax=Inf, ymin=-Inf, alpha = .2) + 
      theme_bw() +
      theme(axis.text.x = element_text(size=6), axis.title = element_text(size=8), plot.title = element_text(size=9)) 
    
    fppi_plot <- ggplot(concs_minmax.df, aes(x = fppi, group=factor(color_order))) +
      geom_density(aes(color=factor(color_order)), show.legend = FALSE) +
      labs(x = "fP-Pi (mmol/l)", y = NULL) +
      geom_vline(xintercept = fppi_recommendations, linetype="solid", color = "black", size=0.2) +
      geom_vline(xintercept = as.numeric(info$true_fppi), linetype="dashed", color = "black", size=0.5) +
      scale_x_continuous(breaks=c(fppi_recommendations,c(0,2,2.5)), limits = c(0.7,2.7)) +
      scale_colour_manual(values = MyPalette) +
      annotate("rect", xmin=-Inf, xmax=fppi_recommendations[1], ymax=Inf, ymin=-Inf, alpha = .2) + 
      annotate("rect", xmin=fppi_recommendations[2], xmax=Inf, ymax=Inf, ymin=-Inf, alpha = .2) + 
      theme_bw() +
      theme(axis.text.x = element_text(size=6), axis.title = element_text(size=8), plot.title = element_text(size=9))
    
    palb_plot <- ggplot(concs_minmax.df, aes(x = palb, color=factor(color_order), group=factor(color_order))) +
      geom_density(aes(color=factor(color_order)), show.legend = FALSE) +
      guides(guide = guide_legend(label.position = "bottom")) +
      labs(x = "P-Alb (g/l)", y = NULL) +
      geom_vline(xintercept = palb_recommendations, linetype="solid", color = "black", size=0.2) +
      geom_vline(xintercept = as.numeric(info$true_palb), linetype="dashed", color = "black", size=0.5) +
      scale_x_continuous(breaks=c(palb_recommendations,30,40), limits = c(30,47)) +
      scale_colour_manual(values = MyPalette) +
      annotate("rect", xmin=-Inf, xmax=palb_recommendations[1], ymax=Inf, ymin=-Inf, alpha = .2) + 
      annotate("rect", xmin=palb_recommendations[2], xmax=Inf, ymax=Inf, ymin=-Inf, alpha = .2) + 
      theme_bw() +
      theme(legend.position="bottom", legend.title = element_blank(), axis.text.x = element_text(size=6), axis.title = element_text(size=8), plot.title = element_text(size=9))
    
    lay <- rbind(c(1,1,3),
                 c(2,2,4),
                 c(2,2,5))
    
    reasoning_plot <- grid.arrange(pot_plot, pho_plot, pk_plot, fppi_plot, palb_plot, layout_matrix = lay, padding=0)
    ggsave(paste0("figures/reasoning_plots/reasoning_plots_",person_id,".pdf"), plot = reasoning_plot, width = 6, height = 6, scale = 1)
    
  } # file exists
}
```

```{r nuts_intake_method_figure, cache=FALSE, eval=TRUE, echo=FALSE,message=FALSE, warning=FALSE, fig.cap="Figure shows detailed intake recommendation for patient 10 from the previous recommendation table. The intake plot on the left shows the posterior samples of diet configurations that result concentrations of plasma potassium (P-K), fasting plasma phosphate (fP-Pi) and plasma albumin (P-Alb) to stay within their recommended limits. These levels are marked with vertical solid lines in the concentration panels. The black point in the middle of intake plot represents the patient's current potassium and phosphorous intake. Current concentrations matching this intake are shown with dashed vertical lines. Reported recommendation is shown with a rectangle that contains $95\\%$ of diet proposals that result recommended concentrations over $90\\%$ accuracy. Colouring of the rectangle sides match the concentration estimates in the right hand panels. The figure is plotted with ggplot2 package for R language (v 3.3.5, https://ggplot2.tidyverse.org)."}
library(ggplot2)
library(gridExtra)
library(ggrepel)
library(dplyr)

# Plot the personal recommendations
for (person_id in 36:36) {
  
  subject_code <- levels(dialysis$potilas)[person_id]

  personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
  recommeded_concentrations <- mebn.get_personal_target_guidelines(personal_info, patient_in_dialysis = TRUE)

  pk_recommendations <- c(recommeded_concentrations$lower_limits[1], recommeded_concentrations$upper_limits[1])
  fppi_recommendations <- c(recommeded_concentrations$lower_limits[2], recommeded_concentrations$upper_limits[2])
  palb_recommendations <- c(recommeded_concentrations$lower_limits[3], recommeded_concentrations$upper_limits[3])
    
#  person_id <- 28
  simulation <- "X50_B50_A50_I50"
  
  accepted_intake <- paste0("./patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/accepted_intake_",person_id,".rds")
  
  if (file.exists(accepted_intake)) {
    personal_recommendation <- paste0("./patient_summary/mv3_cross_two_levels/simulation",simulation,"/overviews/personal_recommendation_",person_id,".rds")
    patient_summary <- readRDS(personal_recommendation)
    
    info <- patient_summary[patient_summary$person_id==person_id,]
    min_k <- min(dialysis[dialysis$potilas == info$subject_code,]$kalium)
    max_k <- max(dialysis[dialysis$potilas == info$subject_code,]$kalium)
    avg_k <- mean(dialysis[dialysis$potilas == info$subject_code,]$kalium)
    
    min_f <- min(dialysis[dialysis$potilas == info$subject_code,]$fosfori)
    max_f <- max(dialysis[dialysis$potilas == info$subject_code,]$fosfori)
    avg_f <- mean(dialysis[dialysis$potilas == info$subject_code,]$fosfori)
    
    # these are not anymore retrieved at simulation
    
    true_concs <- dialysis %>%
     filter(potilas == subject_code) %>%
     select(havainto, pk, fppi, palb)

    info$true_pk <- mean(true_concs$pk)
    info$true_fppi <- mean(true_concs$fppi)
    info$true_palb <- mean(true_concs$palb)
    
    accepted_intake.df <- readRDS(accepted_intake)
  
    if (patient_summary$min_pot != -1)
    {
      concs_minmax.df <- readRDS(paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/concs_minmax_",person_id,".rds"))
    }
    
    rec_file <- paste0("patient_summary/mv3_cross_two_levels/simulation",simulation,"/overviews/personal_recommendation_",person_id,".rds")
    personal_recommendation.df <- readRDS(rec_file)

    MyPalette <- c("#2860F6", "#FF7F0E", "#00BFC4", "#D62728", "#AAAAAA")

    accepted_intake.df$limiting_proposal <- sapply(accepted_intake.df$proposal, function(x) ifelse(x %in% concs_minmax.df$proposal,x,1000000))
    
    if (patient_summary$min_pot == -1)
    {
        intake_plot <- ggplot(accepted_intake.df, aes(x = pot, y = pho)) +
          geom_point(aes(colour=lowest_conc_prob), show.legend = TRUE) +
          labs(x = "Potassium (mg/d)", y = "Phosphorous (mg/d)") +
          annotate("pointrange",x = avg_k, y = avg_f, ymin = min_f, ymax = max_f, xmin = min_k, xmax = max_k, size = 0.1, colour = "black") +
          scale_colour_gradient2(low = "#FFFFFF",
                                 high = "#0000FF",
                                 midpoint = 0.75,
                                 breaks = seq(0.5, 1, by = 0.05),
                                 limits = c(0.5, 1),
                                 labels = as.character(seq(50, 100, by = 5))) +
          scale_x_continuous(limits=c(0,5000), breaks=c(0,1000,2000,3000,4000,5000)) +
          scale_y_continuous(limits=c(0,2500), breaks=c(0,500,1000,1500,2000,2500)) + 
          theme(legend.position="bottom", axis.text.x = element_text(size=6), axis.title = element_text(size=6), plot.title = element_text(size=10)) + 
          guides(colour = guide_colorbar(title = "Probability of reaching target concs.", title.theme = element_text(size=7), title.position = "top", barwidth = unit(80,"mm"))) 
          # geom_label_repel(aes(label = proposal, colour = proposal),
          #                  data = subset(accepted_intake.df, limiting_proposal < 1000000),
          #                  box.padding   = 0.35, 
          #                  point.padding = 0.5,
          #                  segment.color = "grey")
        
        reasoning_plot <- intake_plot
    } 
    else
    {
      lim_proposals <- accepted_intake.df %>% filter(limiting_proposal < 1000000)

      min_pot <- lim_proposals[which.min(lim_proposals$pot),]$proposal
      max_pot <- lim_proposals[which.max(lim_proposals$pot),]$proposal
      min_pho <- lim_proposals[which.min(lim_proposals$pho),]$proposal
      max_pho <- lim_proposals[which.max(lim_proposals$pho),]$proposal

      # Order density colors like this
      
      proposal_order <- data.frame(proposal = c(min_pot, max_pot, min_pho, max_pho))
      proposal_order$color_order <- c(1,2,3,4)
      
      concs_minmax.df <- concs_minmax.df %>% inner_join(proposal_order, by = "proposal")
      
      # Plotting

      intake_plot <- ggplot(subset(accepted_intake.df, lowest_conc_prob >= 0.50), aes(x = pot, y = pho)) +
        geom_point(aes(colour=lowest_conc_prob), show.legend = TRUE) +
        geom_rect(fill = "#FFFFFF00", color = "white", size = 0.6,
                    aes(xmin = as.numeric(personal_recommendation.df$min_pot),
                    ymin = as.numeric(personal_recommendation.df$min_pho),
                    xmax = as.numeric(personal_recommendation.df$max_pot),
                    ymax = as.numeric(personal_recommendation.df$max_pho))) +
        geom_rect(fill = MyPalette[1], color = MyPalette[1], size = 0.6,
                    aes(xmin = as.numeric(personal_recommendation.df$min_pot),
                    ymin = as.numeric(personal_recommendation.df$min_pho),
                    xmax = as.numeric(personal_recommendation.df$max_pot),
                    ymax = as.numeric(personal_recommendation.df$min_pho))) +
        geom_rect(fill = MyPalette[2], color = MyPalette[2], size = 0.6,
                    aes(xmin = as.numeric(personal_recommendation.df$min_pot),
                    ymin = as.numeric(personal_recommendation.df$max_pho),
                    xmax = as.numeric(personal_recommendation.df$max_pot),
                    ymax = as.numeric(personal_recommendation.df$max_pho))) +
        geom_rect(fill = MyPalette[3], color = MyPalette[3], size = 0.6,
                    aes(xmin = as.numeric(personal_recommendation.df$min_pot),
                    ymin = as.numeric(personal_recommendation.df$min_pho),
                    xmax = as.numeric(personal_recommendation.df$min_pot),
                    ymax = as.numeric(personal_recommendation.df$max_pho))) +
        geom_rect(fill = MyPalette[4], color = MyPalette[4], size = 0.6,
                    aes(xmin = as.numeric(personal_recommendation.df$max_pot),
                    ymin = as.numeric(personal_recommendation.df$min_pho),
                    xmax = as.numeric(personal_recommendation.df$max_pot),
                    ymax = as.numeric(personal_recommendation.df$max_pho))) +        
        labs(x = "Potassium (mg/d)", y = "Phosphorous (mg/d)") +
        annotate("pointrange",x = avg_k, y = avg_f, ymin = min_f, ymax = max_f, xmin = min_k, xmax = max_k, size = 0.1, colour = "black") +
        scale_colour_gradient2(low = "#FFFFFF",
                               high = "#0096FF",
                               midpoint = 0.75,
                               breaks = seq(0.5, 1, by = 0.05),
                               limits = c(0.5, 1),
                               labels = as.character(seq(50, 100, by = 5))) +
        scale_x_continuous(limits=c(0,5800), breaks=c(0,1000,2000,3000,4000,5000,5800)) +
        scale_y_continuous(limits=c(0,2550), breaks=c(0,500,1000,1500,2000,2550)) + 
        theme(legend.position="bottom", axis.text = element_text(size=6), axis.title = element_text(size=8), plot.title = element_text(size=10)) + 
        guides(colour = guide_colorbar(title = "Probability % of reaching target concentrations", title.theme = element_text(size=8), label.theme = element_text(size=6), title.position = "top", barwidth = unit(80,"mm"))) 
        # geom_label_repel(aes(label = proposal, colour = proposal),
        #                  data = subset(accepted_intake.df, limiting_proposal < 1000000),
        #                  box.padding   = 0.35, 
        #                  point.padding = 0.5,
        #                  segment.color = "grey")
      
      # what kind of concentration these intakes result?
      pk_plot <- ggplot(concs_minmax.df, aes(x = pk, group=factor(color_order))) +
        geom_density(aes(colour=factor(color_order)), show.legend = FALSE) +
        labs(x = "P-K (mmol/l)", y = NULL, title=element_blank()) +
        geom_vline(xintercept = pk_recommendations, linetype="solid", color = "black", size=0.2) +
        geom_vline(xintercept = as.numeric(info$true_pk), linetype="dashed", color = "black", size=0.5) +
        scale_x_continuous(breaks=c(pk_recommendations,3,4,5,6), limits=c(pk_recommendations,2,3,4,5,6,7)) +
        scale_colour_manual(values = MyPalette) +
        annotate("rect", xmin=-Inf, xmax=pk_recommendations[1], ymax=Inf, ymin=-Inf, alpha = .2) + 
        annotate("rect", xmin=pk_recommendations[2], xmax=Inf, ymax=Inf, ymin=-Inf, alpha = .2) + 
        theme_bw() +
        theme(axis.text.x = element_text(size=6), axis.title = element_text(size=8), plot.title = element_text(size=9)) 
      
      fppi_plot <- ggplot(concs_minmax.df, aes(x = fppi, group=factor(color_order))) +
        geom_density(aes(color=factor(color_order)), show.legend = FALSE) +
        labs(x = "fP-Pi (mmol/l)", y = NULL) +
        geom_vline(xintercept = fppi_recommendations, linetype="solid", color = "black", size=0.2) +
        geom_vline(xintercept = as.numeric(info$true_fppi), linetype="dashed", color = "black", size=0.5) +
        scale_x_continuous(breaks=c(fppi_recommendations,c(0,2,2.5)), limits = c(0.7,2.7)) +
        scale_colour_manual(values = MyPalette) +
        annotate("rect", xmin=-Inf, xmax=fppi_recommendations[1], ymax=Inf, ymin=-Inf, alpha = .2) + 
        annotate("rect", xmin=fppi_recommendations[2], xmax=Inf, ymax=Inf, ymin=-Inf, alpha = .2) + 
        theme_bw() +
        theme(axis.text.x = element_text(size=6), axis.title = element_text(size=8), plot.title = element_text(size=9))
      
      palb_plot <- ggplot(concs_minmax.df, aes(x = palb, color=factor(color_order), group=factor(color_order))) +
        geom_density(aes(color=factor(color_order)), show.legend = FALSE) +
        guides(guide = guide_legend(label.position = "bottom")) +
        labs(x = "P-Alb (g/l)", y = NULL) +
        geom_vline(xintercept = palb_recommendations, linetype="solid", color = "black", size=0.2) +
        geom_vline(xintercept = as.numeric(info$true_palb), linetype="dashed", color = "black", size=0.5) +
        scale_x_continuous(breaks=c(palb_recommendations,30,40), limits = c(30,47)) +
        scale_colour_manual(values = MyPalette) +
        annotate("rect", xmin=-Inf, xmax=palb_recommendations[1], ymax=Inf, ymin=-Inf, alpha = .2) + 
        annotate("rect", xmin=palb_recommendations[2], xmax=Inf, ymax=Inf, ymin=-Inf, alpha = .2) + 
        theme_bw() +
        theme(legend.position="bottom", legend.title = element_blank(), axis.text.x = element_text(size=6), axis.title = element_text(size=8), plot.title = element_text(size=9))
      
      lay <- rbind(c(1,1,2),
                   c(1,1,3),
                   c(1,1,4))
      
      #reasoning_plot <- grid.arrange(intake_plot, pk_plot, fppi_plot, palb_plot, nrow = 2, ncol=2, padding=0) 
      reasoning_plot <- grid.arrange(intake_plot, pk_plot, fppi_plot, palb_plot, layout_matrix = lay, padding=0)
      ggsave(paste0("figures/reasoning_plots/reasoning_plots_",person_id,".pdf"), plot = reasoning_plot, width = 6, height = 6, scale = 1)
    }
    
  } # file exists
}
```

```{r reasoning_plot_ridges, fig.height=8.5, fig.width=8, cache=FALSE,echo=FALSE, message=FALSE, warning=FALSE,fig.cap="The figure shows in two left-most panels personal recommendations of potassium and phosphorous intake ($\\hat{Q}^{min}-\\hat{Q}^{max}$) with predictive distributions of $\\hat{Q}$ illustrated in the background. Each row shows a numeric label of the patient and the type of patient's dialysis treatment (HD = hospital hemodialysis, HHD = home hemodialysis, PD = peritoneal dialysis). Personal recommendations are given for those patients whose resulting plasma concentration levels could be predicted in either over 90\\% probability. Three right-most panels show the estimated concentrations that match the recommended intake. In these panels, grey bars indicate the estimated concentration without the effect of potassium and phosphorous intake, $\\mu_{q0}$. Blue bars indicate the range of concentration that is resulted from modifying phosphorous and potassium intake. It is required that these simulated concentrations stay within the personal target ranges denoted with vertical black lines. The dark blue bar indicates satisfying this requirement in $P^{max} > 90\\%$ confidence and $P^{max} > 80\\%$ confidence would be indicated with light blue, but there aren't any in the results. The best exact probabilities $P^{max}_m$ are shown with percentage figures. Red bars indicate that even the best concentration estimation has $P^{max} < 80\\%$ confidence and personal recommendations are not given for these patients. For these patients, the red and blue bars show the whole reachable ranges. The figure is plotted with ggplot2 package for R language (v 3.3.5, https://ggplot2.tidyverse.org)."}

library(ggridges)
library(ggplot2)
library(grid)
library(gridExtra)

simulation <- "X50_B50_A50_I50"

potassium_org_mean <- mean(dialysis$kalium) # 2755
potassium_org_sd <- sd(dialysis$kalium) # 949
  
phosphorous_org_mean <- mean(dialysis$fosfori) # 2755
phosphorous_org_sd <- sd(dialysis$fosfori) # 949

patient_summary$max_pk_prob <- as.numeric(patient_summary$max_pk_prob)
patient_summary$max_fppi_prob <- as.numeric(patient_summary$max_fppi_prob)
patient_summary$max_palb_prob <- as.numeric(patient_summary$max_palb_prob)

min_accepted_recommandation_probability <- 0.80

accepted_intake.df <- data.frame(matrix(ncol = 9, nrow = 0), row.names = NULL)

for (person_id in 36:36) {
  
  personal_intake_file <- paste0("./patient_summary/mv3_cross_two_levels/simulation",simulation,"/details/accepted_intake_",person_id,".rds")
  
  if (file.exists(personal_intake_file)) {
    
    #personal_recommendation <- paste0("./patient_summary/simulation",simulation,"/overviews/personal_recommendation_",person_id,".rds")

    personal_intake.df <- readRDS(personal_intake_file)
    
    recommendations.df <- personal_intake.df[personal_intake.df$lowest_conc_prob >= min_accepted_recommandation_probability,]
    
    if (nrow(recommendations.df) > 0)
    {
      accepted_intake.df <- rbind(accepted_intake.df, cbind(person_id, recommendations.df))
    } else {
      emptyrow <- as.data.frame(matrix(c(person_id,0,0,0,0,0,0,0,0), ncol = 9, nrow = 1))
      colnames(emptyrow) <- c("person_id","proposal", "pk_prob", "fppi_prob", "palb_prob", "lowest_conc_prob", "iid_prob", "pot", "pho")  
      accepted_intake.df <- rbind(accepted_intake.df, emptyrow)
    }

  } else {
    emptyrow <- as.data.frame(matrix(c(person_id,0,0,0,0,0,0,0,0), ncol = 9, nrow = 1))
    colnames(emptyrow) <- c("person_id","proposal", "pk_prob", "fppi_prob", "palb_prob", "lowest_conc_prob", "iid_prob", "pot", "pho")  
    accepted_intake.df <- rbind(accepted_intake.df, emptyrow)
  }
}

# intake reasoning

patient_summary$person_id <- as.character(patient_summary$person_id)
accepted_intake.df$person_id <- as.character(accepted_intake.df$person_id)

# english abbreviations for dialysis treatments
#patient_summary[patient_summary$treatment == "OHD",]$treatment <- "HD"
#patient_summary[patient_summary$treatment == "KHD",]$treatment <- "HHD"
#patient_summary[patient_summary$treatment == "PD",]$treatment <- "PD"

intake_reasoning.df <- accepted_intake.df %>%
    inner_join(patient_summary, by="person_id") %>%
    mutate(max_conc_prob = as.numeric(max_conc_prob)) %>%
    mutate(max_recom_norm = ifelse(accepted == 1, (as.numeric(max_pot) - potassium_org_mean) / potassium_org_sd + (as.numeric(max_pho) - phosphorous_org_mean) / phosphorous_org_sd + 1000, max_conc_prob)) %>%
  mutate(person_text = paste0(person_id, " ",treatment))

#  mutate(min_pot = ifelse(min_pot == "-1", 0, as.numeric(min_pot))) %>%
#  mutate(max_pot = ifelse(max_pot == "-1", 2500, as.numeric(max_pot))) %>%
#  mutate(min_pho = ifelse(min_pho == "-1", 0, as.numeric(min_pho))) %>%
#  mutate(max_pho = ifelse(max_pho == "-1", 1000, as.numeric(max_pho))) %>%
  
intake_reasoning.df$pot_text <- paste0(round(as.numeric(intake_reasoning.df$min_pot),0)," - ", round(as.numeric(intake_reasoning.df$max_pot),0))
intake_reasoning.df$pho_text <- paste0(round(as.numeric(intake_reasoning.df$min_pho),0)," - ", round(as.numeric(intake_reasoning.df$max_pho),0))

intake_reasoning.df[intake_reasoning.df$min_pho == "-1",]$pot_text <- ""
intake_reasoning.df[intake_reasoning.df$min_pho == "-1",]$pho_text <- ""
                    
# concentration reasoning

personal_effect_summary$person_id <- as.character(personal_effect_summary$person_id)
muq0_summary$person_id <- as.character(muq0_summary$person_id)
personal_targets$person_id <- as.character(personal_targets$person_id)

# TODO: Tallenna myös osittain hyväksytyt pitoisuudet jotta tämä toimisi. näyttäisi kivemmalta.
# nyt _recejä ei ole tallessa

#  mutate(pk_low_rec = ifelse(max_pk_prob >= 0.8, pk_low_rec, pk_low)) %>%
#  mutate(pk_high_rec = ifelse(max_pk_prob >= 0.8, pk_high_rec, pk_high)) %>%

conc_reasoning.df <- patient_summary %>%
  inner_join(personal_effect_summary, by="person_id") %>%
  inner_join(muq0_summary, by="person_id") %>%
  inner_join(personal_targets, by="person_id") %>%
  mutate(accepted = as.numeric(accepted)) %>%
  mutate(max_conc_prob = as.numeric(max_conc_prob)) %>%
  mutate(pk_low_rec = ifelse(accepted == 1, pk_low_rec, pk_low)) %>%
  mutate(pk_high_rec = ifelse(accepted == 1, pk_high_rec, pk_high)) %>%
  mutate(fppi_low_rec = ifelse(accepted == 1, fppi_low_rec, fppi_low_rec)) %>%
  mutate(fppi_high_rec = ifelse(accepted == 1, fppi_high_rec, fppi_high)) %>%
  mutate(palb_low_rec = ifelse(accepted == 1, palb_low_rec, palb_low)) %>%
  mutate(palb_high_rec = ifelse(accepted == 1, palb_high_rec, palb_high)) %>%
  mutate(max_recom_norm = ifelse(accepted == 1, (as.numeric(max_pot) - potassium_org_mean) / potassium_org_sd + (as.numeric(max_pho) - phosphorous_org_mean) / phosphorous_org_sd + 1000, max_conc_prob)) %>%
  mutate(pk_accepted = ifelse(max_pk_prob >= 0.9, "high", ifelse(max_pk_prob >= 0.8, "low", "failed"))) %>%
  mutate(fppi_accepted = ifelse(max_fppi_prob >= 0.9, "high", ifelse(max_fppi_prob >= 0.8, "low", "failed"))) %>%
  mutate(palb_accepted = ifelse(max_palb_prob >= 0.9, "high", ifelse(max_palb_prob >= 0.8, "low", "failed")))

mu_q0_color = "grey"
recom_color = "black"
default_recom_color = "lightgrey"

conc_reasoning.df$pk_prob_text <- paste0(round(conc_reasoning.df$max_pk_prob * 100, 0), "%")
conc_reasoning.df$fppi_prob_text <- paste0(round(conc_reasoning.df$max_fppi_prob * 100, 0), "%")
conc_reasoning.df$palb_prob_text <- paste0(round(conc_reasoning.df$max_palb_prob * 100, 0), "%")
conc_reasoning.df$treatment <- factor(conc_reasoning.df$treatment)

# Special case: No valid combination found for accepted concentrations

no_valid <- conc_reasoning.df %>%
  filter(accepted == 0 & max_pk_prob >= min_accepted_recommandation_probability & max_fppi_prob >= min_accepted_recommandation_probability & max_palb_prob >= min_accepted_recommandation_probability) %>%
  mutate(pk_prob_text = paste0("<",round(as.numeric(max_conc_prob) * 100, 0), "%")) %>%
  mutate(fppi_prob_text = "") %>%
  mutate(palb_prob_text = "") %>%
  mutate(pk_accepted = "failed") %>%
  mutate(fppi_accepted = "failed") %>%
  mutate(palb_accepted = "failed")

conc_reasoning.df[conc_reasoning.df$person_id %in% as.vector(no_valid$person_id),] <- no_valid

ProbColorPalette <- c("#F44336","#4CAF50","#81C784")
ProbColorPalette <- c("#F44336","#0000CD","#00BFFF") # <80%, 90%, 80%

#      geom_text(stat = "unique", aes(x=2500, label=pot_text), size=2.5, width=0.6) +

pot_plot <- ggplot(intake_reasoning.df, aes(x = pot, y = reorder(person_text, max_recom_norm + as.numeric(accepted_recommandation_probability) * 100000), group = person_id)) +
      geom_density_ridges(aes(rel_min_height=0.01, scale = 1.0), fill = "#00BFC4", color = "#009FA4") +
      theme_bw() +
      scale_x_continuous(breaks=c(0,2500,5800), limits = c(0,5850)) +
      geom_text(stat = "unique", aes(x=2500, label=pot_text), size=2.5) +
      geom_vline(xintercept = 2500, linetype="solid", color = "black", size=0.2) +
      labs(x = element_blank(), y = "Patients") +
      theme(axis.text.x = element_text(size=6),axis.title = element_text(size=9), axis.text = element_text(size=7), plot.title = element_text(size=9)) +
      ggtitle("Pot. (mg/d)")

pho_plot <- ggplot(intake_reasoning.df, aes(x = pho, y = reorder(person_id, max_recom_norm + as.numeric(accepted_recommandation_probability) * 100000), group = person_id)) +
      geom_density_ridges(aes(rel_min_height=0.01, scale = 1.3), fill = "#00BFC4", color = "#009FA4") +
      theme_bw() +
      scale_x_continuous(breaks=c(0,1000,2550), limits = c(0,3000)) +
      geom_text(stat = "unique", aes(x=1000, label=pho_text), size=2.5) +
      geom_vline(xintercept = 1000, linetype="solid", color = "black", size=0.2) +
      labs(x = element_blank(), y = element_blank()) +
      theme(axis.text.x = element_text(size=6),axis.title = element_text(size=9), axis.text.y = element_blank(), plot.title = element_text(size=9)) +
      ggtitle("Phosp. (mg/d)")

pk_plot <- ggplot(data = conc_reasoning.df, aes(y = reorder(person_id, max_recom_norm + as.numeric(accepted_recommandation_probability) * 100000)), group = accepted) +
      geom_bar(stat='identity', aes(x=pk_mu_q0), fill=mu_q0_color, color=mu_q0_color, width=0.6, show.legend = FALSE) +
      geom_bar(stat='identity', aes(x=pk_high_rec, fill=pk_accepted), width=0.3, show.legend = FALSE) +
      geom_bar(stat='identity', aes(x=pk_low_rec), fill=mu_q0_color, color=mu_q0_color, width=0.6, show.legend = FALSE) +
      geom_text(aes(x=1, label=pk_prob_text), size=2.5, fontface="bold", color="white") +
      theme_bw() +
      scale_color_manual(aesthetics = "fill", values = ProbColorPalette) + 
      scale_x_continuous(breaks=c(0,3.4,4.7,6)) +
      geom_text(aes(x=pk_lower_limit, label="|"), fontface="plain", size=4, color="black") +
      geom_text(aes(x=pk_upper_limit, label="|"), fontface="plain", size=4, color="black") +
      #geom_point(aes(x=pk_lower_limit), shape=3) +
      #geom_point(aes(x=pk_upper_limit), shape=3) +
      labs(x = element_blank(), y = element_blank()) +
      theme(axis.text.y = element_blank(), axis.text.x = element_text(size=6), axis.title = element_text(size=9), plot.title = element_text(size=9)) +
      ggtitle("P-K (mmol/l)")

fppi_plot <- ggplot(data = conc_reasoning.df, aes(y = reorder(person_id, max_recom_norm + as.numeric(accepted_recommandation_probability) * 100000)), group = accepted) +
      geom_bar(stat='identity', aes(x=fppi_mu_q0), fill=mu_q0_color, color=mu_q0_color, width=0.6, show.legend = FALSE) +
      geom_bar(stat='identity', aes(x=fppi_high_rec, fill=fppi_accepted), width=0.3, show.legend = FALSE) +
      geom_bar(stat='identity', aes(x=fppi_low_rec), fill=mu_q0_color, color=mu_q0_color, width=0.6, show.legend = FALSE) +
      geom_text(aes(x=0.5, label=fppi_prob_text), fontface="bold", size=2.5, color="white") +
      scale_x_continuous(breaks=c(0,0.9,1.78,3)) +
      geom_text(aes(x=fppi_lower_limit, label="|"), fontface="plain", size=4, color="black") +
      geom_text(aes(x=fppi_upper_limit, label="|"), fontface="plain", size=4, color="black") +
      #geom_point(aes(x=fppi_lower_limit), shape=3) +
      #geom_point(aes(x=fppi_upper_limit), shape=3) +
      theme_bw() +
      scale_color_manual(aesthetics = "fill", values = ProbColorPalette) + 
      theme(axis.text.y = element_blank(), axis.text.x = element_text(size=6), axis.title = element_text(size=9), plot.title = element_text(size=9)) +
      labs(x = element_blank(), y = element_blank()) +
      ggtitle("fP-Pi (mmol/l)")

palb_plot <- ggplot(data = conc_reasoning.df, aes(y = reorder(person_id, max_recom_norm + as.numeric(accepted_recommandation_probability) * 100000)), group = accepted) +
      geom_bar(stat='identity', aes(x=palb_mu_q0), fill=mu_q0_color, color=mu_q0_color, width=0.6, show.legend = FALSE) +
      geom_bar(stat='identity', aes(x=palb_high_rec, fill=palb_accepted), width=0.3, show.legend = FALSE) +
      geom_bar(stat='identity', aes(x=palb_low_rec), width=0.6, fill=mu_q0_color, color=mu_q0_color, show.legend = FALSE) +
      #geom_text(aes(x=0.5, label=palb_accepted), fontface="bold", size=2.5, color="white") +
      geom_text(aes(x=7, label=palb_prob_text), fontface="bold", size=2.5, color="white") +
      scale_x_continuous(breaks=c(0,36,45)) +
      geom_text(aes(x=palb_lower_limit), label="|", fontface="plain", size=4, color="black") +
      geom_text(aes(x=palb_upper_limit), label="|", fontface="plain", size=4, color="black") +
      #geom_point(aes(x=palb_lower_limit), shape=3) +
      #geom_point(aes(x=palb_upper_limit), shape=3) +
      theme_bw() +
      scale_color_manual(aesthetics = "fill", values = ProbColorPalette) + 
      theme(axis.text.y = element_blank(), axis.text.x = element_text(size=6), axis.title = element_text(size=9), plot.title = element_text(size=9)) +
      labs(x = element_blank(), y = element_blank()) +
      ggtitle("P-Alb (g/l)")

recommendation_plot <- grid.arrange(pot_plot, pho_plot, pk_plot, fppi_plot, palb_plot, ncol=5,nrow=1, padding=0,widths=c(1.32,1,1,1,1))
ggsave(paste0("figures/recommendation_plot_X50_B50.pdf"), plot = recommendation_plot, width = 6, height = 6, scale = 1)

```




