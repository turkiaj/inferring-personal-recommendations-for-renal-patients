---
output: html_document
date: "2023-03-24"
---

## Cross validation

```{r setup, include=FALSE}
library(knitr)
library(kableExtra) # for HTML and Latex tables

knitr::opts_chunk$set(echo = TRUE, fig.align="center", fig.pos = 'H')

# this allows using tikz rendering for plots with "dev=tikz"
knit_hooks$set(plot = function(x, options) {
  if ('tikz' %in% options$dev && !options$external) {
    hook_plot_tex(x, options)
  } else hook_plot_md(x, options)
})

# Fix seed for random number generator for getting consistent results in kmeans etc.
fixed_seed <- 678

# Load common MEBN package
source("mebn/v2/MEBNv2.r")

```

# Dialysis patient data

```{r data_loading, echo=FALSE, message=FALSE, warning=FALSE}
library(lubridate)
library(dplyr)
library(tidyr)

# Read the data description
datadesc_fat_epros <- read.csv(file="data/DIALYSIS_data_description_fat_epros.csv", header = TRUE, sep = ";")

# Read the actual data matching the description
dialysis <- read.csv(file="data/DIALYSIS.csv", sep=";", dec=",")

# Define factors
dialysis$potilas <- factor(dialysis$potilas)
dialysis$nesterajoitus <- factor(dialysis$nesterajoitus)
dialysis$verenpainelaakitys <- factor(dialysis$verenpainelaakitys)
dialysis$verenrasvojen_laakitys <- factor(dialysis$verenrasvojenlaakitys)
dialysis$mielialalaakitys <- factor(dialysis$mielialalaakitys)
dialysis$fosforinsitoja <- factor(dialysis$fosforinsitoja)
dialysis$kaliuminsitoja <- factor(dialysis$kaliuminsitoja)
dialysis$anemian_hoito <- factor(dialysis$anemianhoito)
dialysis$diabeteslaakitys <- factor(dialysis$diabeteslaakitys)
dialysis$antibiootti <- factor(dialysis$antibiootti)
dialysis$marevan <- factor(dialysis$marevan)
dialysis$nesteenpoisto <- factor(dialysis$nesteenpoisto)
dialysis$ummetuslaake <- factor(dialysis$ummetuslaake)
dialysis$verenohennus <- factor(dialysis$verenohennus)
dialysis$akt_dvit <- factor(dialysis$aktdvit)
dialysis$renavit <- factor(dialysis$renavit)
dialysis$cad <- factor(dialysis$cad)

# Calculate missing E% for fats 
# https://fineli.fi/fineli/fi/ravintotekijat/2331

dialysis$mufaepros <- dialysis$mufa * 9 / dialysis$energiakcal * 100 # Rasvan energiakerroin on 37 kJ/g (9 kcal/g)
dialysis$pufaepros <- dialysis$pufa * 9 / dialysis$energiakcal * 100 # Rasvan energiakerroin on 37 kJ/g (9 kcal/g)
#dialysis$safaepros2 <- dialysis$safa * 9 / dialysis$energiakcal * 100 # Rasvan energiakerroin on 37 kJ/g (9 kcal/g)

# Add these new E% features as predictors
mufa_e <- datadesc_fat_epros[datadesc_fat_epros$Name=="mufa",]
mufa_e$Name <- "mufaepros"
mufa_e$Unit <- "E%"
mufa_e$Description <- "Monounsaturated Fatty Acids, E%"
mufa_e$Descriptionfin <- "Mufa E%"
datadesc_fat_epros <- rbind(datadesc_fat_epros, mufa_e)

pufa_e <- datadesc_fat_epros[datadesc_fat_epros$Name=="pufa",]
pufa_e$Name <- "pufaepros"
pufa_e$Unit <- "E%"
pufa_e$Description <- "Polyunsaturated Fatty Acids, E%"
pufa_e$Descriptionfin <- "Pufa E%"
datadesc_fat_epros <- rbind(datadesc_fat_epros, pufa_e)

# Remove g/d features from predictors
datadesc_fat_epros[datadesc_fat_epros$Name=="mufa",]$Order <- 0
datadesc_fat_epros[datadesc_fat_epros$Name=="pufa",]$Order <- 0

# gender: female = 1, male = 0
dialysis$sukupuoli <- factor(ifelse(dialysis$sukupuoli == "nainen", 1, 0))

# Days between laboratory test and food record interview
dialysis$responsedays <- difftime(as.Date(dialysis$labraaika, '%d.%m.%Y'), as.Date(dialysis$ravhaastaika, '%d.%m.%Y'), units = c("days"))

responsedays_desc <- datadesc_fat_epros[datadesc_fat_epros$Name=="ika",]
responsedays_desc$Order <- 0 # OMITTED !!
responsedays_desc$Distribution <- "Integer"  # Filter this out from normalization etc.
responsedays_desc$Name <- "responsedays"
responsedays_desc$Unit <- "days"
responsedays_desc$Description <- "responsetime"
responsedays_desc$Descriptionfin <- "vasteaika"
datadesc_fat_epros <- rbind(datadesc_fat_epros, responsedays_desc)

# important: dataset is ordered by successive patients and observations so that estimation works correctly
dialysis <- dialysis[order(dialysis$potilas, dialysis$havainto),]

# remove patients with one observation only

# dialysis
patients_with_two_obs <- dialysis %>% 
  group_by(potilas) %>% 
  summarise(havainto_sum = sum(havainto)) %>%
  filter(havainto_sum == 3) %>%
  select(potilas) %>%
  unlist() %>% as.vector()

dialysis <- dialysis[dialysis$potilas %in% patients_with_two_obs,]

# - reset patient levels
dialysis$potilas <- factor(dialysis$potilas)

# Define how to iterate through the graph
# - same targets
assumedtargets <- datadesc_fat_epros[datadesc_fat_epros$Order==200,]
```

```{r two_sets_of_predictors, echo=FALSE, message=FALSE}
# - different sets of predictors

## FAT EPROS
assumedpredictors_fat_epros <- datadesc_fat_epros[datadesc_fat_epros$Order==100,]

# Ordering for table
assumedpredictors_fat_epros <- assumedpredictors_fat_epros[order(assumedpredictors_fat_epros$Unit, assumedpredictors_fat_epros$Description),]

gaussian_preds <- as.vector(assumedpredictors_fat_epros[assumedpredictors_fat_epros$Distribution == "Gaussian" | assumedpredictors_fat_epros$Distribution == "LogNormal",]$Name)
show_decimals <- as.vector(assumedpredictors_fat_epros[assumedpredictors_fat_epros$Distribution == "Gaussian" | assumedpredictors_fat_epros$Distribution == "LogNormal",]$Decimals)

pred_table <- as.data.frame(assumedpredictors_fat_epros[assumedpredictors_fat_epros$Distribution == "Gaussian" | assumedpredictors_fat_epros$Distribution == "LogNormal",]$Description, row.names = NULL)

range_mat <- paste0(round(apply(t(dialysis[gaussian_preds]), 1, function(x) mean(x)),show_decimals), " (",round(apply(t(dialysis[gaussian_preds]), 1, function(x) min(x)),show_decimals)," - ",round(apply(t(dialysis[gaussian_preds]), 1, function(x) max(x)),show_decimals),") ", as.vector(assumedpredictors_fat_epros[assumedpredictors_fat_epros$Distribution == "Gaussian",]$Unit))

prior_range <- paste0(assumedpredictors_fat_epros[assumedpredictors_fat_epros$Distribution == "Gaussian",]$Lowerbound, " - ", assumedpredictors_fat_epros[assumedpredictors_fat_epros$Distribution == "Gaussian",]$Upperbound, " ", assumedpredictors_fat_epros[assumedpredictors_fat_epros$Distribution == "Gaussian",]$Unit)

pred_table_fat_epros <- cbind(pred_table, range_mat)
colnames(pred_table_fat_epros) <- c("Nutrient", "Sample avg. (min-max)")
```

```{r model_separate_univariate_preparation, echo=FALSE, eval=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
library(rstan)
source("mebn/v2/MEBNv2.r")

rstan_options (auto_write=TRUE)
options (mc.cores=parallel::detectCores ()) 
```


```{r graph_with_gamma_qr_mvcross_two_levels, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
pk_fppi_palb_targets <- datadesc_fat_epros[datadesc_fat_epros$Name %in% c('pk','fppi','palb'),]

initial_graph <- mebn.fully_connected_bipartite_graph(datadesc_fat_epros)

dialysis_imputed <- readRDS("data/DIALYSIS_imputed_palb.rds")

# add the dialysis treatment type as a grouping factor
dialysis_imputed$hoitoryhma <- as.factor(dialysis_imputed$hoitomuoto)

# and sort the data by treatment/patient/observation
dialysis_imputed <- dialysis_imputed[order(dialysis_imputed$hoitoryhma, 
                                           dialysis_imputed$potilas, dialysis_imputed$havainto),]

# 10-fold
number_of_folds <- 10
patients <- as.numeric(levels(dialysis_imputed$potilas))
patient_folds <- split(patients, cut(seq_along(patients),number_of_folds,labels = FALSE))

# number of fold
f <- 10

fold <- patient_folds[[f]]

# Data to holdout belonging to patients in the fold

dialysis_holdout <- dialysis_imputed[!dialysis_imputed$potilas %in% fold,]
dialysis_holdout$potilas <- factor(dialysis_holdout$potilas) # recalculate patients
dialysis_holdout$hoitoryhma <- factor(dialysis_holdout$hoitoryhma) # recalculate groups
no_holdout <- rep(0, nrow(dialysis_holdout))

# Change this path to match your environment
cvmodelpath <- "models/BLMM_gamma_mv_cross"
fold_title <- paste0(f,"_",paste0(fold, collapse = "_"))
cvdir <- paste0(cvmodelpath, "/cvmodels/", fold_title)
                     
if (!dir.exists(cvdir))
{
  dir.create(cvdir)
  
  dialdiet_gamma_mv3_two_level <- mebn.bipartite_two_level_multivariate(
                                     reaction_graph = initial_graph, 
                                     inputdata = dialysis_holdout,
                                     targetdata = no_holdout,
                                     predictor_columns = assumedpredictors_fat_epros, 
                                     assumed_targets = pk_fppi_palb_targets, 
                                     group_column = "hoitoryhma",
                                     subject_column = "potilas",
                                     local_estimation = mebn.two_level_multivariate_sampling,
                                     local_model_cache = cvdir,
                                     stan_model_file = 
                                       "mebn/v2/BLMM_gamma_two_level_grouping.stan",
                                     normalize_values = TRUE)
}

```


```{r prediction}
library(rstan)
source("mebn/v2/MEBNv2.r")

stan_model_file <- "mebn/v2/BLMM_gamma_two_level_prediction.stan"

# reponses
pk_fppi_palb_targets <- datadesc_fat_epros[datadesc_fat_epros$Name %in% c('pk','fppi','palb'),]
assumedtargets <- pk_fppi_palb_targets

# data
dialysis_imputed <- readRDS("data/DIALYSIS_imputed_palb.rds")

# add the dialysis treatment type as a grouping factor
dialysis_imputed$hoitoryhma <- as.factor(dialysis_imputed$hoitomuoto)

# and sort the data by treatment/patient/observation
dialysis_imputed <- dialysis_imputed[order(dialysis_imputed$hoitoryhma, 
                                           dialysis_imputed$potilas, dialysis_imputed$havainto),]

# pick predicted fold
number_of_folds <- 10
patients <- as.numeric(levels(dialysis_imputed$potilas))
patient_folds <- split(patients, cut(seq_along(patients),number_of_folds,labels = FALSE))

# number of fold
f <- 10
fold <- patient_folds[[f]]
fold_title <- paste0(f,"_",paste0(fold, collapse = "_"))

inputdata <- dialysis_imputed[dialysis_imputed$potilas %in% fold,]
predictor_columns <- assumedpredictors_fat_epros
target_columns <- pk_fppi_palb_targets
group_column <- "hoitoryhma"
subject_column <- "potilas"
targetdata <- NULL
normalize_values <- TRUE
reg_params <- NULL

# Recalculate indexes of remaining patients and groups
inputdata$potilas <- factor(inputdata$potilas) # recalculate patients
#inputdata$hoitoryhma <- factor(inputdata$hoitoryhma) # do not refactor because g_stack has all levels 

# prepare input data
stanDat <- mebn.set_mv_two_level_model_parameters(predictor_columns, target_columns, group_column, subject_column, inputdata, targetdata, normalize_values, reg_params)
stanDat$n_s <- length(fold)

# get prediction info
localfit <- readRDS(paste0("models/BLMM_gamma_mv_cross/cvmodels/",fold_title,"/pk_fppi_palb_blmm.rds"))
#localfit <- readRDS(paste0("/media/sf_cvmodels/",fold_title,"/pk_fppi_palb_blmm.rds"))

pmodel <- rstan::extract(localfit)

params <- within(list(),
                 {
                   beta_Intercept <- colMeans(pmodel$beta_Intercept)       # vector[v] 
                   beta_stack <- colMeans(pmodel$beta_stack)               # vector[v*(p-1)] 
                   g_stack <- colMeans(pmodel$g_stack)                     # vector[v*k][n_g]
                   g_alpha <- colMeans(pmodel$g_alpha)                     # vector[v] 
                   L_s <- colMeans(pmodel$L_s)                             # cholesky_factor_corr[v*k]
                   stacked_sigma_b_s <- colMeans(pmodel$stacked_sigma_b_s) # vector[v*k]
                 })
  
params <- c(stanDat, params)

rstan_options (auto_write=TRUE)
options (mc.cores=parallel::detectCores ())
  
pred_result <- stan(file=stan_model_file, warmup = 1000, iter=2000, chains=4, chain_id=1L, algorithm="NUTS", control = list(adapt_delta = 0.99, max_treedepth = 15), data=params, seed=483892929)

saveRDS(pred_result, paste0("models/BLMM_gamma_mv_cross/cvmodels/",fold_title,"/prediction_of_fold_",f,".rds"))

#f1 <- rstan::extract(pred_result)

#colMeans(f1$personal_effect)[1,,]

#colMeans(pmodel$personal_effect)[1,,]

```


```{r insert_personal_predictions_to_graphs}
library(igraph)
library(rstan)
source("mebn/v2/MEBNv2.r")

# This script takes personal predictions from file in fold
# prediction_of_fold_X.rds and updates them to existing graph

dialysis_imputed <- readRDS("data/DIALYSIS_imputed_palb.rds")

# add the dialysis treatment type as a grouping factor
dialysis_imputed$hoitoryhma <- as.factor(dialysis_imputed$hoitomuoto)

# and sort the data by treatment/patient/observation
dialysis_imputed <- dialysis_imputed[order(dialysis_imputed$hoitoryhma, 
                                           dialysis_imputed$potilas, dialysis_imputed$havainto),]

graph_person_id <- 1
person_id <- 1
f <- 1
fold_title <- "1_382_480_885_1184"

subject_code <- levels(dialysis_imputed$potilas)[graph_person_id]
print(subject_code)

personal_model_dir <- paste0("graphs/mv3_cross_two_levels_cv/",graph_person_id) 
graphpath <- paste0(personal_model_dir,"/personal_graph.graphml")
print(graphpath)

reaction_graph <- read.graph(graphpath, "graphml")
  
#localfit <- readRDS(paste0("models/BLMM_gamma_mv_cross/cvmodels/",fold_title,"/prediction_of_fold_",f,".rds"))
localfit <- readRDS(paste0("/media/sf_cvmodels/",fold_title,"/prediction_of_fold_",f,".rds"))

predictor_columns <- assumedpredictors_fat_epros
target_variables <- datadesc_fat_epros[datadesc_fat_epros$Name %in% c('pk','fppi','palb'),]

# Overwrite beta and intercept with the predicted values

for (c in 1:dim(target_variables)[1])
{
  #c <- 1
  
  target_column <- target_variables[c,]
  target_name <- as.vector(target_column$Name)
  target_vertex <- V(reaction_graph)[target_name]
  
  # - predicted intercept
  
  localfit_p_intercept <- extract(localfit, pars = c(paste0("personal_intercept[",person_id,",",c,"]")))
  int_samples_file <- paste0(target_name, "_personal_intercept.rds")
  
  # update the distribution file of intercept
  saveRDS(localfit_p_intercept, paste0(personal_model_dir, "/", int_samples_file))
  
  # update personal_intercept in graph also
  reaction_graph <- set_vertex_attr(reaction_graph, "personal_intercept", target_vertex, int_samples_file)

  # extract adjusted effects from the local distribution
  pe <- mebn.personal_effects_from_multivariate(localfit, c, person_id)
    
  # - Loop through betas for current target
  predictor_names <- as.vector(predictor_columns$Name)
    
  for (p in 1:length(predictor_names))
  {
    #p <-1 
    
    pred_column <- predictor_columns[p,]
    predictor_name <- predictor_names[p]
    predictor_vertex <- V(reaction_graph)[predictor_name]
    
    # get the predicted personal effect
    personal_effect_property <- paste0("personal_effect[",person_id,",",c,",",p,"]")
    personal_beta <- extract(localfit, pars = personal_effect_property)
    personal_beta <- unlist(personal_beta, use.names=FALSE) # convert from one item list to vector
    effect_name <- paste0(predictor_name,"_",target_name,"_beta")
    
    # update the personal effect distribution array file  
    saveRDS(personal_beta, paste0(personal_model_dir, "/", effect_name, ".rds"))

    # get edge predictor_name -> target_name
    edge_id <- get.edge.ids(reaction_graph, c(predictor_name,target_name))
    beta_edge <- E(reaction_graph)[edge_id]
    
    print(beta_edge)
     
    reaction_graph <- set_edge_attr(reaction_graph, index = edge_id, name = "weight", value = pe$personal_effect[p])
    reaction_graph <- set_edge_attr(reaction_graph, index = edge_id, name = "value", value = pe$personal_effect[p])
    reaction_graph <- set_edge_attr(reaction_graph, index = edge_id, name = "value_lCI", value = pe$personal_effect_lCI[p])
    reaction_graph <- set_edge_attr(reaction_graph, index = edge_id, name = "value_uCI", value = pe$personal_effect_uCI[p])
    reaction_graph <- set_edge_attr(reaction_graph, index = edge_id, name = "b", value = pe$b[p])          
    reaction_graph <- set_edge_attr(reaction_graph, index = edge_id, name = "b_lCI", value = pe$b_lCI[p])
    reaction_graph <- set_edge_attr(reaction_graph, index = edge_id, name = "b_uCI", value = pe$b_uCI[p])  

    # personal effect vertex 
    pe_vertex <- V(reaction_graph)[paste0("personal_", predictor_name, "_", target_name)]
    vertex_id <- as.integer(pe_vertex)
    
    reaction_graph <- set_vertex_attr(reaction_graph, index = vertex_id, name = "value", value = pe$personal_effect[p])
    reaction_graph <- set_vertex_attr(reaction_graph, index = vertex_id, name = "value_lCI", value = pe$personal_effect_lCI[p])
    reaction_graph <- set_vertex_attr(reaction_graph, index = vertex_id, name = "value_uCI", value = pe$personal_effect_uCI[p])
    reaction_graph <- set_vertex_attr(reaction_graph, index = vertex_id, name = "mode", value = 0)

    # Personal variation (b)) vertex
    b_vertex <- V(reaction_graph)[paste0("b_", predictor_name, "_", target_name)]
    vertex_id <- as.integer(b_vertex)
    
    reaction_graph <- set_vertex_attr(reaction_graph, index = vertex_id, name = "b", value = pe$b[p])          
    reaction_graph <- set_vertex_attr(reaction_graph, index = vertex_id, name = "b_lCI", value = pe$b_lCI[p])
    reaction_graph <- set_vertex_attr(reaction_graph, index = vertex_id, name = "b_uCI", value = pe$b_uCI[p])  
    reaction_graph <- set_vertex_attr(reaction_graph, index = vertex_id, name = "mode", value = 0)  

    # Save the updated graph
    write.graph(reaction_graph, paste0(personal_model_dir,"/personal_graph.graphml"), "graphml")
  }
}


```


```{r prediction_without_cholesky}
library(rstan)
source("mebn/v2/MEBNv2.r")

stan_model_file <- "mebn/v2/BLMM_gamma_two_level_prediction_observations.stan"

# reponses
pk_fppi_palb_targets <- datadesc_fat_epros[datadesc_fat_epros$Name %in% c('pk','fppi','palb'),]
assumedtargets <- pk_fppi_palb_targets

# data
dialysis_imputed <- readRDS("data/DIALYSIS_imputed_palb.rds")

# add the dialysis treatment type as a grouping factor
dialysis_imputed$hoitoryhma <- as.factor(dialysis_imputed$hoitomuoto)

# and sort the data by treatment/patient/observation
dialysis_imputed <- dialysis_imputed[order(dialysis_imputed$hoitoryhma, 
                                           dialysis_imputed$potilas, dialysis_imputed$havainto),]

# pick predicted fold
number_of_folds <- 10
patients <- as.numeric(levels(dialysis_imputed$potilas))
patient_folds <- split(patients, cut(seq_along(patients),number_of_folds,labels = FALSE))

# number of fold
f <- 5
fold <- patient_folds[[f]]
fold_title <- paste0(f,"_",paste0(fold, collapse = "_"))

inputdata <- dialysis_imputed[dialysis_imputed$potilas %in% fold,]
predictor_columns <- assumedpredictors_fat_epros
target_columns <- pk_fppi_palb_targets
group_column <- "hoitoryhma"
subject_column <- "potilas"
targetdata <- NULL
normalize_values <- TRUE
reg_params <- NULL

# Recalculate indexes of remaining patients and groups
inputdata$potilas <- factor(inputdata$potilas) # recalculate patients
#inputdata$hoitoryhma <- factor(inputdata$hoitoryhma) # do not refactor because g_stack has all levels 

# prepare input data
stanDat <- mebn.set_mv_two_level_model_parameters(predictor_columns, target_columns, group_column, subject_column, inputdata, targetdata, normalize_values, reg_params)
stanDat$n_s <- length(fold)

# get prediction info
#localfit <- readRDS(paste0("models/BLMM_gamma_mv_cross/cvmodels/",fold_title,"/pk_fppi_palb_blmm.rds"))
localfit <- readRDS(paste0("/media/sf_cvmodels/",fold_title,"/pk_fppi_palb_blmm.rds"))

pmodel <- rstan::extract(localfit)

params <- within(list(),
                 {
                   beta_Intercept <- colMeans(pmodel$beta_Intercept)       # vector[v] 
                   beta_stack <- colMeans(pmodel$beta_stack)               # vector[v*(p-1)] 
                   g_stack <- colMeans(pmodel$g_stack)                     # vector[v*k][n_g]
                   g_alpha <- colMeans(pmodel$g_alpha)                     # vector[v] 
                 })
  
params <- c(stanDat, params)

rstan_options (auto_write=TRUE)
options (mc.cores=parallel::detectCores ())
  
pred_result <- stan(file=stan_model_file, warmup = 1000, iter=2000, chains=4, chain_id=1L, algorithm="NUTS", control = list(adapt_delta = 0.99, max_treedepth = 15), data=params, seed=483892929)

saveRDS(pred_result, paste0("models/BLMM_gamma_mv_cross/cvcomparison/",fold_title,"/prediction_of_fold_",f,".rds"))

```

```{r Mahalanobis}
library(Matrix)
library(igraph)
library(rstan)


# Assume L is the estimated Cholesky matrix
f <- 5
fold_title <- "1_382_480_885_1184"
fold_title <- "2_1439_1581_1882_1960"
fold_title <- "3_1983_2303_2440"
fold_title <- "4_2459_2638_2714_2884"
fold_title <- "5_2928_4025_4710_4741"

#bestfit <- readRDS("models/BLMM_gamma_mv_cross/two_levels/pk_fppi_palb_blmm.rds")

cvfit <- readRDS(paste0("/media/sf_cvmodels/",fold_title,"/pk_fppi_palb_blmm.rds"))

cvmodel <- rstan::extract(cvfit)
L_s <- colMeans(cvmodel$L_s)
T_s <- colMeans(cvmodel$stacked_sigma_b_s)

# Get estimate personal coefficients b_est for the new patient based on new data only
obsfit <- readRDS(paste0("models/BLMM_gamma_mv_cross/cvcomparison/",fold_title,"/prediction_of_fold_",f,".rds"))

md_summary <- data.frame(matrix(ncol = 3, nrow = 0), row.names = NULL)

# start index of all patients
graph_person_id <- 16

for (person_id in 1:4)
{
  subject_code <- levels(dialysis_imputed$potilas)[graph_person_id]
  
  b_obs <- c()
  b_best <- c()
  
  for (c in 1:dim(assumedtargets)[1])
  {
    pe_obs <- mebn.personal_effects_from_multivariate(obsfit, c, person_id)
    b_obs <- c(b_obs, as.vector(pe_obs$b))
  }

  for (c in 1:dim(assumedtargets)[1])
  {
    pe_best <- mebn.personal_effects_from_multivariate(bestfit, c, person_id)
    b_best <- c(b_best, as.vector(pe_best$b))
  }
  
  # Estimate how far b_obs is from distribution of previously learned reactions L_s 
  # with Mahalanobis distance
  
  D <- diag(T_s)
  C <- D %*% L_s %*% t(L_s) %*% t(D)
  
  inv_C <- solve(C) # 69 x 69
  
  b_diff <- b_obs - b_best
  
  Mahalanobis_distance <- sqrt(t(b_diff) %*% inv_C %*% b_diff)
  
  personal_md <- cbind(graph_person_id, subject_code, Mahalanobis_distance)
  md_summary <- rbind(md_summary, personal_md)
  
  graph_person_id <- graph_person_id + 1
}

colnames(md_summary) <- c("person_id", "subject", "mahalanobis_distance")
saveRDS(md_summary, "model_evaluation/mahalanobis_distance_5.rds")


md1 <- readRDS("model_evaluation/mahalanobis_distance_1.rds")
md2 <- readRDS("model_evaluation/mahalanobis_distance_2.rds")
md3 <- readRDS("model_evaluation/mahalanobis_distance_3.rds")
md4 <- readRDS("model_evaluation/mahalanobis_distance_4.rds")
md5 <- readRDS("model_evaluation/mahalanobis_distance_5.rds")

md <- rbind(md1,md2,md3,md4,md5)
md

saveRDS(md, "model_evaluation/mahalanobis_distance.rds")

```


```{r simulated_MSE_for_cv, eval=FALSE, echo=FALSE}
library(igraph)
source("mebn/v2/MEBNv2.r")

potassium_org_mean <- mean(dialysis$kalium) # 2755
potassium_org_sd <- sd(dialysis$kalium) # 949
  
phosphorous_org_mean <- mean(dialysis$fosfori) # 2755
phosphorous_org_sd <- sd(dialysis$fosfori) # 949

pk_mean <- mean(dialysis$pk)
fppi_mean <- mean(dialysis$fppi)
palb_mean <- mean(dialysis$palb, na.rm = TRUE)

cv_mse_summary <- data.frame(matrix(ncol = 5, nrow = 0), row.names = NULL)

graph_dir_candidates <- c("mv3_cross_two_levels_cv")

for (model_dir in graph_dir_candidates) {

  graph_dir <- paste0("graphs/",model_dir,"/")

  for (person_id in 1:37) {
  
    print(paste0("Simulating patient ", person_id))
  
    subject_code <- levels(dialysis$potilas)[person_id]
    treatment <- unique(dialysis[dialysis$potilas == subject_code,]$hoitomuoto)
    
    # Normal ranges of concentration are personalized
    personal_info <- head(dialysis[dialysis$potilas == subject_code,],1)
    recommeded_concentrations <- mebn.get_personal_target_guidelines(personal_info, patient_in_dialysis = TRUE)
    
    personal_model_dir <- paste0(graph_dir,person_id)
    personal_graph <- read.graph(paste0(personal_model_dir, "/personal_graph.graphml"), "graphml")
    
    # Sample diet proposals and matching concentration predictions
    
    repeat_model <- mebn.Query(reaction_graph = personal_graph,
                           graph_dir = personal_model_dir,
                           queried_nodes = c("kalium","fosfori"),
                           query = recommeded_concentrations,
                           proposal_limits = c(((0 - potassium_org_mean) / potassium_org_sd),
                                             ((5800 - potassium_org_mean) / potassium_org_sd),
                                             ((0 - phosphorous_org_mean) / phosphorous_org_sd),
                                             ((2550 - phosphorous_org_mean) / phosphorous_org_sd)),                         
                           stan_model_file = "diet/multivariate_intake_recommendation.stan",
                           conc_lower_limits = as.vector(recommeded_concentrations$lower_limits),
                           conc_upper_limits = as.vector(recommeded_concentrations$upper_limits),
                           beta_point_est = "mean",
                           param_point_est = "mean",
                           X_point_est = "mean",
                           posterior_samples = 1,
                           X_sd_coef = 1,
                           repeat_only = 1)
  
    repeats <- rstan::extract(repeat_model)
   
    pk <- repeats$concentration[,,1]
    fppi <- repeats$concentration[,,2]
    palb <- repeats$concentration[,,3]
     
    true_concs <- dialysis %>%
         filter(potilas == subject_code) %>%
         select(havainto, pk, fppi, palb)
    
    personal_mse <- cbind(subject_code,
                              model_dir,
                              mebn.NRMSE(mean(pk), mean(true_concs$pk), pk_mean),
                              mebn.NRMSE(mean(fppi), mean(true_concs$fppi), fppi_mean),
                              mebn.NRMSE(mean(palb), mean(true_concs$palb), palb_mean))

    cv_mse_summary <- rbind(cv_mse_summary, personal_mse)
  }
}

colnames(cv_mse_summary) <- c("subject", "reaction_model", "pk_nrmse", "fppi_nrmse", "palb_nrmse")

saveRDS(cv_mse_summary, "model_evaluation/NRMSE_comparison_mv_cv_models.rds")

write.csv2(cv_mse_summary, file="model_evaluation/NRMSE_comparison_mv_cv_models.csv", row.names = FALSE)

```

```{r error_analysis}
library(dplyr)
library(ggplot2)
library(igraph)

cv_mse_summary <- readRDS("model_evaluation/NRMSE_comparison_mv_cv_models.rds")
mse_summary <- readRDS("model_evaluation/NRMSE_comparison_mv_models.rds")
mse_summary <- mse_summary[mse_summary$reaction_model == "mv3_cross_two_levels",]

error_analysis.df <- mse_summary %>%
  inner_join(cv_mse_summary, by = "subject") %>%
  mutate(pk_error = abs(as.numeric(pk_nrmse.x) - as.numeric(pk_nrmse.y))) %>%
  mutate(fppi_error = abs(as.numeric(fppi_nrmse.x) - as.numeric(fppi_nrmse.y))) %>%
  mutate(palb_error = abs(as.numeric(palb_nrmse.x) - as.numeric(palb_nrmse.y))) %>%
  select(subject, pk_error, fppi_error, palb_error)

error_analysis.df$avg_error <- rowMeans(cbind(error_analysis.df$pk_error, error_analysis.df$fppi_error, error_analysis.df$palb_error))

# Hypoteesi: virhe kasvaa jos holdout-potilas reagoi eri tavalla kuin malli ennustaa
# Verrataan CV-mallin yleistä vaikutusta ja sillä CV-foldilla ennustettua henkilökohtaista vaikutusta

md_summary <- readRDS("model_evaluation/mahalanobis_distance.rds")

error_join.df <- error_analysis.df %>% inner_join(md_summary, by="subject")

pk_plot.df <- data.frame(concentratrion = "pk", error = error_join.df$pk_error, mahalanobis_distance = round(as.numeric(error_join.df$mahalanobis_distance),2))
fppi_plot.df <- data.frame(concentratrion = "fppi", error = error_join.df$fppi_error, mahalanobis_distance = round(as.numeric(error_join.df$mahalanobis_distance),2))
palb_plot.df <- data.frame(concentratrion = "palb", error = error_join.df$palb_error, mahalanobis_distance = round(as.numeric(error_join.df$mahalanobis_distance),2))

plot.df <- rbind(pk_plot.df, fppi_plot.df, palb_plot.df)

pk_fit <- lm(error ~ mahalanobis_distance, data=pk_plot.df)
fppi_fit <- lm(error ~ mahalanobis_distance, data=fppi_plot.df)
palb_fit <- lm(error ~ mahalanobis_distance, data=palb_plot.df)

ggplot(plot.df) +
  geom_point(aes(y = error, x = mahalanobis_distance, color = concentratrion)) +
  geom_abline(slope = pk_fit$coefficients[2],
                intercept = pk_fit$coefficients[1],
                color="blue",
                linewidth=0.5) +
  geom_abline(slope = fppi_fit$coefficients[2],
                intercept = fppi_fit$coefficients[1],
                color="red",
                linewidth=0.5) +
  geom_abline(slope = palb_fit$coefficients[2],
                intercept = palb_fit$coefficients[1],
                color="green",
                linewidth=0.5)

```


```{r error_plot}
library(dplyr)
library(ggplot2)
library(igraph)
library(viridis)

cv_mse_summary <- readRDS("model_evaluation/NRMSE_comparison_mv_cv_models.rds")
mse_summary <- readRDS("model_evaluation/NRMSE_comparison_mv_models.rds")
mse_summary <- mse_summary[mse_summary$reaction_model == "mv3_cross_two_levels",]

error_analysis.df <- mse_summary %>%
  inner_join(cv_mse_summary, by = "subject") %>%
  mutate(pk_error = as.numeric(pk_nrmse.x)) %>% 
  mutate(pk_cv_error = as.numeric(pk_nrmse.y)) %>% 
  mutate(fppi_error = as.numeric(fppi_nrmse.x)) %>% 
  mutate(fppi_cv_error = as.numeric(fppi_nrmse.y)) %>% 
  mutate(palb_error = as.numeric(palb_nrmse.x)) %>% 
  mutate(palb_cv_error = as.numeric(palb_nrmse.y)) %>%
  select(subject, pk_error, pk_cv_error, fppi_error, fppi_cv_error, palb_error, palb_cv_error)

error_analysis.df$avg_error <- rowMeans(cbind(error_analysis.df$pk_error, error_analysis.df$fppi_error, error_analysis.df$palb_error), na.rm = TRUE)
error_analysis.df$avg_cv_error <- rowMeans(cbind(error_analysis.df$pk_cv_error, error_analysis.df$fppi_cv_error, error_analysis.df$palb_cv_error), na.rm = TRUE)

patients <- as.numeric(levels(dialysis_imputed$potilas))

error_analysis.df$patient_id <- seq(1:37)
error_analysis.df$fold <- cut(seq_along(patients),number_of_folds,labels = FALSE)
error_analysis.df$fold_color <- factor(error_analysis.df$fold %% 2)

nrmse_plot <- ggplot(error_analysis.df) +
  geom_point(aes(y = reorder(subject, patient_id), x = avg_error), color = "#799fcb") +
  geom_point(aes(y = subject, x = avg_cv_error), color = "#f9665e") +
  geom_segment(aes(y = reorder(subject, patient_id), yend = subject, x = avg_error, xend = avg_cv_error, group = subject, color = fold_color), linetype = "solid", show.legend = FALSE) +
  theme_bw() +
  scale_fill_viridis(discrete = TRUE) + 
  labs(x = "NRMSE", y = "Patient") 

nrmse_plot
ggsave("figures/nrmse_plot.pdf", plot = nrmse_plot)

```


#TODO: remove

```{r}
for (subject_code in error_analysis.df$subject) {
  
  person_id <- which(levels(dialysis_imputed$potilas) == subject_code)
  personal_graph <- read.graph(paste0("graphs/mv3_cross_two_levels_cv/", person_id, "/personal_graph.graphml"), "graphml")
  
  general_effects <- V(personal_graph)[V(personal_graph)$type == "general_effect"]
  pk_general_effects <- general_effects[endsWith(general_effects$name, "_pk")]
  fppi_general_effects <- general_effects[endsWith(general_effects$name, "_fppi")]
  palb_general_effects <- general_effects[endsWith(general_effects$name, "_palb")]
  
  personal_effects <- V(personal_graph)[V(personal_graph)$type == "personal"]
  pk_personal_effects <- personal_effects[endsWith(personal_effects$name, "_pk")]
  fppi_personal_effects <- personal_effects[endsWith(personal_effects$name, "_fppi")]
  palb_personal_effects <- personal_effects[endsWith(personal_effects$name, "_palb")]

  pk_rms <- mean(abs(pk_general_effects$value - pk_personal_effects$value))
  fppi_rms <- mean(abs(fppi_general_effects$value - fppi_personal_effects$value))
  palb_rms <- mean(abs(palb_general_effects$value - palb_personal_effects$value))
  
  rms_between_general_and_personal <- mean(abs(general_effects$value - personal_effects$value))
  
  reaction_rms <- rbind(reaction_rms, c(subject_code, pk_rms, fppi_rms, palb_rms, rms_between_general_and_personal))
}

colnames(reaction_rms) <- c("subject", "pk_reaction_distance", "fppi_reaction_distance", "palb_reaction_distance", "reaction_distance")
reaction_rms$pk_reaction_distance <- as.numeric(reaction_rms$pk_reaction_distance)
reaction_rms$fppi_reaction_distance <- as.numeric(reaction_rms$fppi_reaction_distance)
reaction_rms$palb_reaction_distance <- as.numeric(reaction_rms$palb_reaction_distance)

```


```{r extract_personal_generative_models_cv, eval=FALSE, echo=FALSE}
source("mebn/v2/MEBNv2.r")

# Extract generative models for patients with data from personal grouping

# - use these predictors and targets
datadesc <- datadesc_fat_epros
target_variables <- datadesc_fat_epros[datadesc_fat_epros$Name %in% c('pk','fppi','palb'),]
assumedpredictors <- assumedpredictors_fat_epros

# 10-fold
number_of_folds <- 10
patients <- as.numeric(levels(dialysis_imputed$potilas))
patient_folds <- split(patients, cut(seq_along(patients),number_of_folds,labels = FALSE))

# number of fold
f <- 1

fold <- patient_folds[[f]]

# Change this path to match your environment
fold_title <- paste0(f,"_",paste0(fold, collapse = "_"))

# - latent parameters from this model
latent_parameter_modeldir <- paste0("models/BLMM_gamma_mv_cross/cvmodels/", fold_title)

latent_parameter_modeldir <- paste0("models/BLMM_gamma_mv_cross/cvmodels/1_382_480_885_1184")
#latent_parameter_modeldir <- paste0("models/BLMM_gamma_mv_cross/cvmodels/1")

# - output personal generative models (graphml + rv samples) in this dir
graph_dir <- "graphs/mv3_cross_two_levels_cv/"
graph_dir <- "graphs/mv3_cross_two_levels_cv_insample/"

# Loop through patients and produce the models

dialysis <- readRDS("data/DIALYSIS_imputed_palb.rds")

# add the dialysis treatment type as a grouping factor
dialysis$hoitoryhma <- as.factor(dialysis$hoitomuoto)

#for (person_id in 1:length(patients)) {

for (person_id in which(patients %in% fold)) {
  
  # - initial graph structure
  initial_graph <- mebn.fully_connected_bipartite_graph(datadesc)
  
  # - pick the estimated latent variables for all the persons
  local_distributions <- target_variables
  local_distributions$modelcache <- latent_parameter_modeldir
  
  # - get personal data, normalized and original
  
  # - statistics for the nutrition levels are calculated from normalized data (as it was in the likelihood estimation)
  predictors <- nrow(assumedpredictors)
  normalized_input <- sapply(1:predictors, mebn.scale_gaussians, data = dialysis, datadesc = assumedpredictors, log_transform_ln = FALSE)
  normalized_input_df <- as.data.frame(normalized_input)
  
  # - pick rows for the selected person
  subject_code <- levels(dialysis$potilas)[person_id]
  personal_data_df <- cbind(dialysis$potilas, normalized_input_df)
  personal_data_df <- personal_data_df[personal_data_df$`dialysis$potilas` == subject_code,]
  personal_data <- as.matrix(subset(personal_data_df, select = -c(`dialysis$potilas`)))
  
  # - store also these original stats in graph
  personal_data_org <- subset(dialysis[dialysis$potilas == subject_code,], select = as.vector(assumedpredictors$Name))
  personal_concentrations_org <- subset(dialysis[dialysis$potilas == subject_code,], select = as.vector(assumedtargets$Name))
  
  personal_model_dir <- paste0(graph_dir, person_id)
  
  # Generate a personal graph in directory
  
  group_id <- as.numeric(unique(dialysis[dialysis$potilas == subject_code,]$hoitoryhma))

  # two-level model
  personal_graph <- mebn.extract_multilevel_graph(person_id, group_id, initial_graph, personal_model_dir, assumedpredictors, assumedtargets, latent_parameter_modeldir, personal_data, personal_data_org, personal_concentrations_org, datadesc)
  
}

```




